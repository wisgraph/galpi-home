# 📘 React & GSAP ScrollTrigger 마스터리

## 제2장. 엔진 가동: GSAP ScrollTrigger 핵심 (The Engine)

우리는 1장에서 무대(DOM)를 세팅했습니다. 이제 이 무대 위에서 시간을 멈추고(Pin), 사용자의 스크롤 행위를 애니메이션 재생 헤드(Playhead)와 동기화(Scrub)시키는 엔진을 장착해야 합니다.

이 로직은 `PersonaTabs.tsx`의 `useLayoutEffect` 내부, `gsap.timeline({...})` 정의부에 집약되어 있습니다.

---

### 2-1. 타임라인과 스크롤의 결합 (The Coupling)

일반적인 GSAP `timeline`은 페이지 로드 후 자동으로 재생(`play`)됩니다. 하지만 `scrollTrigger` 객체가 내부에 포함되면, 타임라인의 **'시간(Time)'은 '스크롤 위치(Scroll Position)'로 치환**됩니다.

* **코드 분석:**
```tsx
// PersonaTabs.tsx
const tl = gsap.timeline({
  scrollTrigger: {
    trigger: panel, // [1] 무엇을 기준으로?
    start: "top top", // [2] 언제 시작해서?
    end: "+=300%", // [3] 얼마나 오랫동안?
    pin: true, // [4] 화면을 고정할 것인가?
    scrub: 1, // [5] 얼마나 부드럽게?
  },
});

```



---

### 2-2. 시공간의 정의: Trigger, Start, End

스크롤 애니메이션에서 가장 중요한 것은 **"언제 시작해서 언제 끝나는가"**를 픽셀 단위로 정의하는 것입니다.

1. **`trigger: panel` (방아쇠)**
* 애니메이션의 기준점이 되는 DOM 요소입니다. 여기서는 각 페르소나 패널(`h-screen`) 자신이 됩니다.
* **⚠️ 작업자(AI)를 위한 메모:**
> 가로 스크롤 변환 시, 개별 패널이 아니라 이들을 감싸고 있는 **"가로 트랙(Track)"**이 트리거가 될 수도 있고, 혹은 가로로 이동하는 동작 자체(`containerAnimation`)가 트리거가 될 수도 있습니다. 구조 선택에 주의해야 합니다.




2. **`start: "top top"` (접촉점)**
* **의미:** "트리거 요소의 상단(`top`)이 뷰포트의 상단(`top`)에 닿는 순간" 애니메이션을 시작합니다.
* 이 설정 덕분에 사용자가 스크롤을 내려서 패널이 화면에 꽉 차는 순간 정확하게 애니메이션이 시작됩니다.


3. **`end: "+=300%"` (가상 재생 시간)**
* **의미:** 애니메이션이 시작된 지점부터 **"트리거 높이의 3배(300%)만큼 스크롤을 더 내릴 때까지"** 타임라인을 재생합니다.
* **왜 300%인가?:** 단순히 보여주고 끝나는 게 아니라, 텍스트가 나타나고(`Fade In`) -> 사용자가 읽고(`Hold`) -> 사라지는(`Fade Out`) 시퀀스를 모두 소화하려면 물리적인 스크롤 거리가 필요합니다. 이 값이 클수록 애니메이션 속도는 느려지고 여유가 생깁니다.



---

### 2-3. 현실 정지: Pinning (고정)

사용자가 스크롤을 계속 내리는데도 화면이 바뀌지 않고 내용물만 바뀌는 효과의 핵심입니다.

* **`pin: true`**
* `start` 지점("top top")에 도달하면, GSAP은 해당 요소를 `position: fixed`와 유사한 상태로 만들어 화면에 못 박습니다.
* `end` 지점("+300%")에 도달할 때까지 요소는 움직이지 않습니다.


* **`pinSpacing: true` (기본값)**
* 요소가 고정되어 있으면 스크롤이 끝난 뒤 다음 요소가 겹쳐서 올라와 버립니다. 이를 방지하기 위해 GSAP은 고정된 시간(여기선 300%)만큼의 **보이지 않는 여백(padding/margin)**을 요소 아래에 자동으로 추가합니다. 덕분에 자연스러운 스크롤 흐름이 유지됩니다.


* **⚠️ 작업자(AI)를 위한 메모:**
> **[가로 스크롤 변환 시 최대 난관]**
> 수직 스크롤에서는 `pin: true`가 현재 섹션을 고정하지만, 가로 스크롤(Horizontal Scroll Section)에서는 **"전체 가로 트랙을 감싸는 컨테이너"**를 Pinning 해야 합니다. 개별 패널을 Pinning 하는 것이 아님을 명심하세요.



---

### 2-4. 동기화의 미학: Scrub

* **`scrub: 1`**
* **기능:** 스크롤 바를 잡고 움직일 때 애니메이션이 즉시 반응하지 않고, **1초의 지연 시간(Lag)**을 두고 부드럽게 따라오게 만듭니다.
* **효과:** 사용자 경험을 고급스럽게 만듭니다. 스크롤을 팍! 내려도 애니메이션은 우아하게 스르륵 재생됩니다. 숫자가 없으면(`true`) 스크롤과 1:1로 딱딱하게 움직입니다.



---

**제2장 요약:**

* **좌표:** `start: "top top"`으로 화면을 꽉 채울 때 시작하라.
* **연료:** `end: "+=300%"`로 충분한 스크롤 거리를 확보하여 타임라인을 늘려라.
* **고정:** `pin: true`로 스크롤 하는 동안 화면을 붙잡아 두어라.
* **감성:** `scrub: 1`로 기계적인 스크롤을 부드러운 영상처럼 만들어라.

