# 📘 React & GSAP ScrollTrigger 마스터리

## 제3장. 연출의 기술: 타임라인 시퀀싱 (The Sequence)

2장에서 우리는 스크롤 바를 300%만큼 늘려놓았습니다. 이제 이 긴 시간을 무대 위 배우들(DOM 요소)에게 배분해야 합니다. `PersonaTabs.tsx`에 구현된 애니메이션은 철저하게 계산된 **3단계 구조(Enter - Hold - Exit)**를 따릅니다.

---

### 3-1. Phase 1: 등장 (Enter) - 시차를 둔 유입

모든 요소가 한꺼번에 '짠' 하고 나타나면 촌스럽습니다. 시선이 자연스럽게 흐르도록 **순서와 시차(Stagger/Delay)**를 두어야 합니다.

* **코드 분석:**
```tsx
// PersonaTabs.tsx

// 1. 배경: 가장 먼저 등장하여 분위기를 잡습니다.
if (background) {
  tl.fromTo(background,
    { scale: 1.2, opacity: 0 }, // 약간 확대된 상태에서
    { scale: 1, opacity: 1, duration: 2, ease: "power2.out" } // 제자리로 차분히 가라앉음
  );
}

// 2. 텍스트 컨텐츠: 배경이 자리 잡은 뒤(0.5초 후) 따라옵니다.
if (content) {
  tl.fromTo(content,
    { y: 50, autoAlpha: 0 }, // 아래에서 위로
    { y: 0, autoAlpha: 1, duration: 2, ease: "power3.out" },
    "<+0.5" // [중요] 이전 애니메이션 시작 시간보다 0.5초 늦게 시작 (Position Parameter)
  );
}

```


* **핵심 기술: Position Parameter (`<`, `+=`, `-=`)**
* GSAP 타임라인은 기본적으로 앞의 애니메이션이 끝나야 다음 것이 실행됩니다.
* 하지만 `<+0.5`와 같은 파라미터를 쓰면 **"앞 녀석이 시작된 지 0.5초 뒤에 나도 출발할래"**가 가능해집니다. 덕분에 물 흐르듯 겹치는(Overlapping) 연출이 가능합니다.


* **`autoAlpha` vs `opacity`:**
* 단순 `opacity: 0`은 눈에만 안 보일 뿐 클릭이 가능하여 UI를 방해할 수 있습니다.
* `autoAlpha: 0`은 GSAP이 `opacity: 0`과 동시에 `visibility: hidden` 처리까지 해줍니다. 등장 전에는 아예 없는 존재로 취급하므로 훨씬 안전합니다.



---

### 3-2. Phase 2: 정지 (Hold) - 읽을 시간 확보 (The Empty Tween)

가장 중요하지만 초보자가 가장 많이 놓치는 부분입니다. 애니메이션이 끝났다고 바로 다음 섹션으로 넘어가면 사용자는 텍스트를 읽을 시간이 없습니다.

* **코드 분석:**
```tsx
// PersonaTabs.tsx

// 5. [Hold] 읽는 시간 확보
// 이 구간 동안 사용자는 내용을 읽습니다. 화면은 고정되어 있습니다.
tl.to({}, { duration: 4 });

```


* **원리:**
* 빈 객체 `{}`를 대상으로 아무런 속성 변화 없이 `duration: 4`만 주었습니다.
* 타임라인 상에서 4초(스크롤 거리로 환산된 시간) 동안 **"아무 일도 일어나지 않는 구간"**을 강제로 만듭니다.
* 이때 사용자는 멈춰 있는 완성된 화면을 보며 텍스트를 읽습니다.


* **⚠️ 작업자(AI)를 위한 메모:**
> 가로 스크롤 구현 시에도 이 **Empty Tween**은 필수입니다. 패널이 화면 중앙에 도착했을 때 바로 지나가지 않고 잠시 멈춰있는 느낌을 주려면 이 코드를 절대 빼먹지 마세요.



---

### 3-3. Phase 3: 퇴장 (Exit) - 우아한 마무리

스크롤이 끝나갈 때쯤, 고정(Pin)이 풀리기 직전에 내용물을 먼저 치워야 합니다. 그렇지 않으면 고정이 풀리면서 내용물이 위로 쑥 올라가는 부자연스러운 모습이 연출됩니다.

* **코드 분석:**
```tsx
// PersonaTabs.tsx

// 6. [Exit] 퇴장
// 핀이 풀리기 전에 내용이 먼저 투명해지며 사라집니다.
tl.to([content, solution, features], {
  y: -50, // 살짝만 위로 뜨면서 (상승감)
  autoAlpha: 0, // 완전히 사라짐
  duration: 2,
  stagger: 0.05, // 다같이 사라지되 약간의 시차
  ease: "power2.in", // 가속하며 사라짐 (빨려 들어가는 느낌)
});

```


* **원리:**
* **선 정리, 후 해제:** `Pin`이 풀리는 시점(`end`)에 도달하기 전에 모든 시각적 요소를 `opacity: 0`으로 만듭니다.
* 이렇게 하면 사용자는 "화면이 위로 올라간다"는 느낌 대신, "현재 이야기가 페이드 아웃 되고 다음 이야기가 나온다"는 **영화적인 전환(Cinematic Transition)**을 느끼게 됩니다.



---

**제3장 요약:**

* **등장:** `<` 파라미터로 시차를 두어라.
* **정지:** `to({}, {duration: 4})`로 텍스트 읽을 시간을 벌어라.
* **퇴장:** 핀이 풀리기 전에 미리 사라지게 하여 전환을 부드럽게 하라.

