# 📘 [기술 문서] PersonaTabs.tsx 스크롤 시퀀스 아키텍처

## 1. 개요 (Architecture Overview)

이 컴포넌트는 **GSAP ScrollTrigger**의 **Pinning(고정)** 기술을 사용하여, 사용자의 스크롤 행위를 '페이지 이동'이 아닌 **'타임라인 재생(Playback)'**으로 치환하는 방식을 사용합니다.

* **핵심 원리:** 뷰포트(화면)에 섹션을 못 박아두고(`Pin`), 스크롤 바가 내려가는 물리적 거리를 애니메이션의 재생 시간으로 사용합니다.
* **구현 파일:** `PersonaTabs.tsx`

---

## 2. 핵심 엔진: ScrollTrigger 설정 분석

애니메이션의 심장부입니다. 이 설정이 없으면 단순한 CSS 애니메이션에 불과합니다.

```typescript
// PersonaTabs.tsx 내부
const tl = gsap.timeline({
  scrollTrigger: {
    trigger: panel,      // [1] 기준점: 각 페르소나 패널 DOM
    start: "top top",    // [2] 시작 시점: 패널의 상단이 화면 상단에 닿을 때
    end: "+=300%",       // [3] 재생 길이: 화면 높이의 3배만큼 스크롤 할 동안 재생
    pin: true,           // [4] 고정: 재생 동안 패널을 화면에 고정 (Sticky)
    pinSpacing: true,    // [5] 여백: 고정된 만큼 아래쪽에 빈 공간 자동 추가
    scrub: 1,            // [6] 동기화: 스크롤 바와 애니메이션을 1초 딜레이로 부드럽게 연결
  },
});

```

### 🔍 상세 해설

1. **`start: "top top"` & `pin: true**`:
* 패널이 화면에 꽉 차는 순간, GSAP은 해당 패널에 `position: fixed`와 유사한 스타일을 적용해 화면에 고정시킵니다. 사용자가 스크롤을 내려도 화면은 내려가지 않습니다.


2. **`end: "+=300%"` (가상 타임라인 생성)**:
* 화면은 멈췄지만 스크롤 바는 계속 내려갑니다.
* **300% (뷰포트 높이의 3배)**만큼의 스크롤 거리를 확보하여, 이 거리를 애니메이션의 **총 러닝타임**으로 사용합니다.
* *원리:* 300% 중 0%는 애니메이션 시작, 150%는 중간, 300%는 끝입니다.


3. **`scrub: 1`**:
* 사용자가 스크롤을 멈추면 애니메이션도 멈춥니다. 단, `1`초의 여유를 두어 기계적인 느낌을 없애고 관성 효과를 줍니다.



---

## 3. 타임라인 시퀀스 상세 분석 (3막 구조)

확보된 300%의 시간을 쪼개서 **"등장(Enter) → 정지(Hold) → 퇴장(Exit)"**의 드라마를 만듭니다.

### 제1막: 순차적 등장 (Entrance)

요소들이 한 번에 나오지 않고 시차를 두고 등장하여 고급스러움을 연출합니다.

```typescript
// 1. 배경 (Background)
tl.fromTo(background,
  { scale: 1.2, opacity: 0 }, // 약간 확대된 상태에서
  { scale: 1, opacity: 1, duration: 2 } // 제자리로 안착
);

// 2. 텍스트 (Left Content)
tl.fromTo(content,
  { y: 50, autoAlpha: 0 },
  { y: 0, autoAlpha: 1, duration: 2 },
  "<+0.5" // [중요] 배경 등장 0.5초 후 시작 (겹침 효과)
);

// 3. 이미지 (Right Solution)
tl.fromTo(solution,
  { y: 50, scale: 0.9, autoAlpha: 0 },
  { y: 0, scale: 1, autoAlpha: 1, duration: 2 },
  "<+0.2" // [중요] 텍스트보다 0.2초 늦게 시작
);

```

* **핵심 기술 (`<` 파라미터):** 앞 애니메이션이 끝나길 기다리지 않고, 상대적인 시간차를 두고 실행시켜 물 흐르는 듯한 연출을 합니다.

### 제2막: 정지 및 정독 (The Hold) ⭐ 핵심

이 코드가 없으면 애니메이션이 끝나자마자 화면이 넘어가 버려서, 사용자가 글을 읽을 수 없습니다.

```typescript
// 5. [중요] 읽는 시간 확보
// 아무 변화 없는 빈 애니메이션(Dummy Tween)을 넣습니다.
tl.to({}, { duration: 4 });

```

* **원리:** 타임라인 중간에 **'공백'**을 넣습니다. 스크롤 거리로 환산하면 약 100~150% 구간 동안은 화면에 아무 변화 없이 내용이 유지됩니다. 이때 사용자가 컨텐츠를 읽습니다.

### 제3막: 선제적 퇴장 (Exit)

핀이 풀리기 전에 내용물을 먼저 치워버립니다.

```typescript
// 6. 퇴장 (Exit)
tl.to([content, solution, features], {
  y: -100,      // 위로 살짝 떠오르며
  autoAlpha: 0, // 투명하게 사라짐
  duration: 2,
  stagger: 0.05 // 다같이 사라지되 약간의 시차
});

```

* **목적:** 스크롤이 끝까지 도달(`end`)해서 핀이 풀리면, 화면이 훅 올라갑니다. 이때 내용물이 남아있으면 "스크롤 되어 잘리는" 느낌을 줍니다.
* **효과:** 미리 투명하게 사라지게 함으로써, **"증발하고 다음 섹션이 나오는"** 영화적인 전환(Cinematic Transition)을 구현합니다.

---

## 4. 리액트 연동 및 최적화 패턴

리액트의 가상 돔(Virtual DOM)과 GSAP의 실제 돔(Real DOM) 제어 간의 충돌을 막기 위한 안전장치입니다.

### 4.1. `useLayoutEffect` 사용

* **코드:** `useLayoutEffect(() => { ... }, [])`
* **이유:** `useEffect`는 화면이 그려진 후 실행되어 깜빡임(FOUC)이 발생할 수 있습니다. `useLayoutEffect`는 화면이 그려지기 전 레이아웃 계산 단계에서 실행되어, ScrollTrigger가 정확한 좌표를 잡게 해줍니다.

### 4.2. `gsap.context`와 `revert`

* **코드:**
```typescript
const ctx = gsap.context(() => { ... }, container);
return () => ctx.revert();

```


* **이유:** 리액트는 컴포넌트 재렌더링 시 이전 애니메이션을 자동으로 삭제하지 않습니다. `ctx.revert()`를 통해 컴포넌트가 사라지거나 업데이트될 때 **기존 애니메이션과 스크롤 이벤트를 깨끗이 청소(Cleanup)**하여 메모리 누수와 애니메이션 중복 실행을 막습니다.

### 4.3. DOM 참조 관리 (`Ref Array`)

* **코드:** `panelsRef.current.forEach((panel, i) => { ... })`
* **이유:** 여러 개의 섹션(`personas.map`)을 제어해야 하므로, 단일 `useRef`가 아닌 배열 형태의 `ref`를 사용하여 각 패널 DOM을 개별적으로 추적합니다.

# 📄 [최종 명세서] PersonaTabs 스크롤 애니메이션 기술 문서

## 1. 아키텍처 개요

이 컴포넌트는 `GSAP ScrollTrigger`의 **Pinning(고정)** 기술을 사용하여 구현되었습니다.
사용자가 스크롤을 내리는 물리적 행위를 페이지 이동이 아닌, **'애니메이션 타임라인 재생'**으로 치환합니다.

* **파일:** `PersonaTabs.tsx`
* **핵심 기술:** React `useLayoutEffect`, GSAP `Timeline`, `ScrollTrigger (Pin, Scrub)`

---

## 2. 핵심 설정값 (Magic Numbers) 명세

이 수치들이 애니메이션의 '느낌(Feeling)'을 결정합니다. 수정 시 이 값을 참고하십시오.

| 설정 항목 | 코드 값 | 의미 및 역할 |
| --- | --- | --- |
| **재생 길이** | `end: "+=300%"` | 화면 높이(`100vh`)의 **3배**만큼 스크롤 할 동안 애니메이션이 진행됨. 숫자가 클수록 애니메이션이 천천히 재생됨. |
| **부드러움** | `scrub: 1` | 스크롤을 멈춰도 **1초** 동안은 관성으로 애니메이션이 부드럽게 움직임. |
| **정독 시간** | `duration: 4` | 애니메이션 중간에 빈 시간(`Dummy Tween`)을 4초(타임라인 기준) 할당하여, 사용자가 글을 읽을 시간을 확보함. |
| **등장 시차** | `<+0.5` | 앞 요소가 등장하기 시작한 지 **0.5초 뒤**에 다음 요소가 등장함. (자연스러운 겹침 효과) |

---

## 3. 동작 시퀀스 (Choreography)

300%의 스크롤 구간 동안 다음 순서대로 실행됩니다.

1. **Pinning (고정):** 패널이 화면에 꽉 차면(`top top`) 스크롤을 내려도 화면이 멈춥니다.
2. **Entrance (등장):**
* 배경(Background)이 줌아웃되며 등장.
* **0.5초 후** 텍스트(Left Content)가 위로(`y:0`) 올라옴.
* **0.2초 후** 솔루션(Right Image)이 커지며(`scale:1`) 등장.


3. **Hold (유지):** 약 150%의 스크롤 구간 동안 화면 변화 없이 멈춰있습니다. (사용자 정독 시간)
4. **Exit (퇴장):** 고정이 풀리기 직전, 모든 내용물이 위로 뜨면서(`y:-100`) 투명해집니다(`autoAlpha:0`).

---

## 4. 코드 구현 패턴 (Best Practices)

리액트 환경에서의 충돌 방지를 위한 필수 패턴입니다.

* **`useLayoutEffect`:** 화면 깜빡임(FOUC) 방지를 위해 렌더링 직후 동기적으로 실행.
* **`gsap.context()`:** 컴포넌트 언마운트 시 애니메이션을 깨끗하게 청소(`revert`)하여 메모리 누수 방지.
* **`Selector Scope`:** `panel.querySelector(...)`를 사용하여, 해당 패널 내부의 요소만 정확하게 타겟팅.


