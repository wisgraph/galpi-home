# 📘 [마스터 교과서] React & GSAP ScrollTrigger: PersonaTabs 스크롤 애니메이션의 모든 것

## 제1장. 핵심 원리: 스크롤을 시간으로 치환하다 (Architecture)

이 애니메이션의 본질은 **"스크롤을 내리는 물리적 행위를, 제자리에서 영화가 재생되는 시간으로 바꾸는 것"**입니다.

### 1.1 물리적 구조: 고정(Pinning)

일반적인 웹사이트는 스크롤 하면 화면이 올라갑니다. 하지만 이 컴포넌트는 **화면을 강제로 멈춥니다.**

* **구현 코드:** `scrollTrigger: { pin: true }`
* **작동 원리:**
1. 패널이 화면에 꽉 차는 순간(`start: "top top"`), GSAP은 해당 패널을 `position: fixed` 상태로 만들어 뷰포트에 **못 박아버립니다.**
2. 사용자가 스크롤을 내려도 패널은 움직이지 않고 제자리에 있습니다.



### 1.2 가상 타임라인: 재생 시간 확보

화면은 멈췄지만, 애니메이션이 재생될 **'시간(스크롤 거리)'**이 필요합니다.

* **구현 코드:** `scrollTrigger: { end: "+=300%", scrub: 1 }`
* **작동 원리:**
1. 화면 높이(`100vh`)의 **3배(300%)**에 달하는 가상의 스크롤 거리를 생성합니다.
2. 이 300%의 거리가 곧 **애니메이션의 러닝타임(0% ~ 100%)**이 됩니다.
3. `scrub: 1` 설정으로 스크롤 바의 움직임을 1초 딜레이를 두고 부드럽게 따라오게 하여, 뚝뚝 끊기는 느낌을 없앱니다.



---

## 제2장. 애니메이션 시퀀스: 등장과 퇴장의 안무 (Choreography)

확보된 300%의 시간 동안, 요소들은 **"배경 → 텍스트 → 정독 → 퇴장"** 순서로 정교하게 페이드인/아웃 됩니다.

### 2.1 [Phase 1] 배경 등장 (Atmosphere Entrance)

가장 먼저 배경이 깔리며 공간감을 조성합니다.

* **시각 효과:** 흐릿하고 확대된 배경이 → 선명해지고 제자리로 돌아옵니다.
* **애니메이션 값:**
* **Scale:** `1.2` (확대됨) → `1.0` (원상복구)
* **Opacity:** `0` (투명) → `1` (불투명)


* **코드:**
```typescript
tl.fromTo(background, { scale: 1.2, opacity: 0 }, { scale: 1, opacity: 1, duration: 2 });

```



### 2.2 [Phase 2] 컨텐츠 등장 (Content Fade-In)

배경이 깔린 후, 정보(텍스트와 이미지)가 순차적으로 등장합니다.

* **텍스트 (왼쪽):** 배경보다 **0.5초** 늦게 등장
* **효과:** 아래에서 위로 떠오르며 페이드인.
* **값:** `y: 50` → `0`, `autoAlpha: 0` → `1`


* **이미지 (오른쪽):** 텍스트보다 **0.2초** 늦게 등장
* **효과:** 약간 작았다가 커지며 위로 떠오름.
* **값:** `scale: 0.9` → `1.0`, `y: 50` → `0`, `autoAlpha: 0` → `1`


* **코드:**
```typescript
// 텍스트 (<+0.5 : 앞 동작 시작 후 0.5초 뒤)
tl.fromTo(content, { y: 50, autoAlpha: 0 }, { y: 0, autoAlpha: 1 }, "<+0.5");
// 이미지 (<+0.2 : 앞 동작 시작 후 0.2초 뒤)
tl.fromTo(solution, { y: 50, scale: 0.9, autoAlpha: 0 }, { y: 0, scale: 1, autoAlpha: 1 }, "<+0.2");

```



### 2.3 [Phase 3] 정지 및 정독 (The Hold) ⭐ 중요

애니메이션이 끝난 후, 사용자가 글을 읽을 수 있도록 화면을 멈춥니다.

* **시각 효과:** 화면에 아무런 변화가 없음. (정지 상태)
* **구현 원리:** **'빈 애니메이션(Dummy Tween)'**을 타임라인에 삽입하여 시간을 끕니다.
* **코드:**
```typescript
// 타임라인 상에서 4초(스크롤 거리로 약 1 화면 분량) 동안 대기
tl.to({}, { duration: 4 });

```



### 2.4 [Phase 4] 퇴장 (Fade-Out & Lift)

다음 섹션이 오기 전에 현재 요소들이 **증발하듯** 사라집니다.

* **시각 효과:** 모든 내용물이 **위로 살짝 뜨면서** 투명해집니다. 스크롤 되어 올라가는 것이 아니라, 공기 중으로 사라지는 느낌입니다.
* **애니메이션 값:**
* **Y축:** `0` → `-50` (위로 상승)
* **Opacity:** `1` → `0` (페이드 아웃)


* **코드:**
```typescript
tl.to([content, solution, features], {
  y: -50,       // 위로 가볍게 상승
  autoAlpha: 0, // 투명하게 사라짐
  duration: 2,  // 사라지는 속도
  stagger: 0.05 // 다같이 사라지되 미세한 시차 적용
});

```



---

## 제3장. 기술 명세: 매직 넘버 (Magic Numbers)

이 수치들을 조정하면 애니메이션의 '느낌(Feeling)'이 달라집니다.

| 속성 | 현재 값 | 역할 및 조정 가이드 |
| --- | --- | --- |
| **Scroll End** | `+=300%` | **전체 재생 길이.** 값을 늘리면(예: 500%) 애니메이션이 더 천천히 진행됨. |
| **Scrub** | `1` | **부드러움.** `0`이면 스크롤과 1:1로 딱딱하게 반응, 숫자가 클수록 물속에 있는 듯 부드러움. |
| **Duration** | `2` (등장/퇴장) | **변화 속도.** 페이드인/아웃이 얼마나 빠르게 일어나는지 결정. |
| **Hold Duration** | `4` | **읽는 시간.** 이 값을 늘리면 정지해 있는 시간이 길어짐. |
| **Stagger** | `0.1` | **시차.** 리스트 아이템들이 얼마나 간격을 두고 따닥-따닥 나타날지 결정. |

---

## 제4장. 리액트 통합 패턴 (Integration)

리액트 환경에서 버그 없이 GSAP을 구동하기 위한 필수 안전장치입니다.

1. **FOUC 방지 (`useLayoutEffect`):**
* `useEffect` 대신 사용하여, 브라우저가 화면을 그리기 전에 애니메이션 초기 위치를 미리 세팅합니다. 깜빡임 현상을 막습니다.


2. **메모리 누수 방지 (`gsap.context`):**
* `ctx.revert()`를 사용하여 컴포넌트가 사라질 때(Unmount) 기존 애니메이션을 완벽하게 제거합니다. 이것이 없으면 애니메이션이 중복 실행되어 성능이 저하됩니다.


3. **동적 참조 (`Ref Array`):**
* `panelsRef.current.forEach`를 사용하여, 데이터(`personaData`) 개수만큼 자동으로 ScrollTrigger를 생성합니다.

# 📘 [최종 마스터 청사진] PersonaTabs 스크롤 애니메이션 명세서

## 1. 아키텍처 개요 (Architecture)

이 컴포넌트는 **GSAP ScrollTrigger**의 **Pinning(고정)** 기술을 사용하여, 사용자의 스크롤 행위를 '페이지 이동'이 아닌 **'타임라인 재생(Playback)'**으로 치환합니다.

* **구현 파일:** `PersonaTabs.tsx`
* **핵심 기술:** React `useLayoutEffect`, GSAP `Timeline`, `ScrollTrigger`

---

## 2. 엔진 설정: ScrollTrigger (The Engine)

애니메이션의 물리적 환경을 정의합니다.

| 설정 항목 | 값 | 설명 |
| --- | --- | --- |
| **Start** | `"top top"` | 패널 상단이 화면 상단에 닿을 때 고정 시작. |
| **End** | `"+=300%"` | **화면 높이의 3배**만큼 스크롤 할 동안 애니메이션 재생. (타임라인 총 길이) |
| **Pin** | `true` | 재생 기간 동안 화면을 고정(`position: fixed` 효과). |
| **Scrub** | `1` | 스크롤을 멈춰도 **1초** 동안은 관성으로 움직임 (부드러운 감속). |

---

## 3. 타임라인 시퀀스 & 이징 (Choreography & Easing) ⭐ 핵심

확보된 300%의 시간 동안 실행되는 **4단계 시퀀스**입니다. **Easing(가속도)** 설정이 느낌을 결정합니다.

### **[Phase 1] 등장 (Entrance)**

순차적으로 등장하며 시선의 흐름을 유도합니다.

1. **배경 (`.persona-bg`)**:
* **동작:** `Scale 1.2 → 1.0` + `Opacity 0 → 1`
* **Easing:** `power2.out` (처음엔 빠르다가 끝에 부드럽게 감속)
* **Duration:** `2`


2. **왼쪽 텍스트 (`.persona-content`)**:
* **동작:** `Y 50 → 0` + `AutoAlpha 0 → 1`
* **Timing:** 배경 시작 후 **0.5초 뒤** (`<+0.5`)
* **Easing:** `power3.out` (강한 감속, 쫀득한 느낌)


3. **오른쪽 이미지 (`.persona-solution`)**:
* **동작:** `Scale 0.9 → 1.0` + `Y 50 → 0` + `AutoAlpha 0 → 1`
* **Timing:** 텍스트 시작 후 **0.2초 뒤** (`<+0.2`)
* **Easing:** `power3.out`


4. **특징 리스트 (`.persona-feature`)**:
* **동작:** `X 30 → 0` + `AutoAlpha 0 → 1`
* **Timing:** 이미지 시작 후 **0.5초 뒤** (`<+0.5`)
* **Stagger:** `0.1` (아이템별 0.1초 간격으로 따닥-따닥 등장)



### **[Phase 2] 정지 및 정독 (The Hold)**

* **동작:** 화면 변화 없음. (스크롤을 내려도 멈춰 있는 구간)
* **구현:** `tl.to({}, { duration: 4 })` (빈 애니메이션 삽입)
* **목적:** 사용자가 내용을 읽을 수 있는 시간 확보 (전체 스크롤의 약 30% 구간 차지).

### **[Phase 3] 퇴장 (Exit)**

다음 섹션 진입 전 증발하듯 사라집니다.

* **대상:** 컨텐츠, 솔루션, 특징 리스트 전체
* **동작:** `Y 0 → -50` (위로 상승) + `AutoAlpha 1 → 0` (투명)
* **Easing:** `power2.in` (점점 빨라지며 사라짐, 흡입되는 느낌)
* **Duration:** `2`
* **동시 동작:** 배경도 `Scale 1.0 → 1.1` + `Opacity 0`으로 함께 사라짐.

---

## 4. DOM 구조 및 참조 전략 (Implementation Strategy)

AI 구현 시 이 구조를 준수해야 합니다.

1. **Ref 배열 (`panelsRef`)**:
* 단일 `useRef`가 아닌 `useRef<HTMLDivElement[]>([])`를 사용하여, `personas.map`으로 생성되는 N개의 패널을 모두 추적해야 함.


2. **Selector Scope**:
* `document.querySelector` 금지.
* 반드시 `panel.querySelector(".persona-content")`와 같이 **현재 패널 내부**에서만 요소를 찾아야 함.


3. **레이어링 (CSS)**:
* 각 패널은 `h-screen` (높이 100vh) 필수.
* 배경은 `absolute inset-0`, 컨텐츠는 `relative z-10`으로 겹침 배치.



---

## 5. 리액트 안전 수칙 (Safety)

1. **FOUC 방지:** 반드시 `useLayoutEffect` 사용.
2. **클린업:** `gsap.context()`로 래핑하고 `return () => ctx.revert()` 필수. (메모리 누수 방지)
3. **리프레시:** 데이터 변경 시 `ScrollTrigger.refresh()` 호출.

---

**[검토 완료]**
이제 완벽합니다. **Easing(`power3.out` 등)**과 **Stagger(`0.1`)**, **타겟팅 방법(Scope)**까지 명시되었으므로, 이 문서를 건네주면 AI는 1픽셀의 오차도 없이 원본과 똑같은 "쫀득한" 애니메이션을 구현해낼 것입니다.


