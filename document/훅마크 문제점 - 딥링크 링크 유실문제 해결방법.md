
백엔드를 **Rust + JSONL + In-Memory**로 완전히 개편하면서, 가장 골치 아픈 **"링크 유실(Link Rot)"** 문제(파일 이동, 이름 변경, 백업 복구 시 링크 깨짐)를 해결할 수 있는 **이중 안전장치 전략**을 제안합니다.

훅마크가 자주 실패하는 지점이 바로 여기입니다. 단순히 파일 경로(Path)만 저장하거나, OS가 관리하는 `Alias`에만 의존하면 마이그레이션 때 다 깨집니다.

선생님의 앱(HookLink)은 **"파일이 도망가도 끝까지 쫓아가는 좀비 같은 추적 능력"**을 가져야 합니다. 이를 위해 macOS의 두 가지 핵심 기술을 조합해야 합니다.

---

### 전략: "BookmarkData" + "xattr(확장 속성)"의 하이브리드 추적

디비(JSONL)에는 파일의 '위치 정보'를 저장하고, 파일 자체에는 '신분증(UUID)'을 심어놓는 방식입니다.

#### 1. 1차 방어선: macOS `BookmarkData` (aka. Security Scoped Bookmark)

단순히 파일 경로(`/Users/me/doc.pdf`)를 저장하면 안 됩니다. macOS API가 제공하는 **`BookmarkData`**를 사용해야 합니다.

- **원리:** macOS의 `URL.bookmarkData(options:...)` API를 호출하면, 해당 파일의 고유한 바이너리 데이터(Blob)를 줍니다. 이 데이터 안에는 **파일 ID(Inode), 볼륨 ID, 파일 경로**가 모두 암호화되어 들어있습니다.
    
- **구현 방법 (Rust + JSONL):**
    
    1. 사용자가 파일을 링크할 때, Swift/Obj-C 브릿지를 통해 `BookmarkData`를 생성합니다.
        
    2. 이 바이너리 데이터를 **Base64 문자열**로 인코딩해서 JSONL의 `bookmark` 필드에 저장합니다.
        
    3. **추적:** 나중에 앱에서 링크를 열 때, 경로가 아니라 이 `BookmarkData`를 먼저 해석(Resolve)합니다. 파일 이름이 바뀌거나 폴더가 이동되어도 OS가 "아, 그 파일 여기로 갔어" 하고 새 경로를 찾아줍니다.
        
- **장점:** 파인더에서 파일을 이리저리 옮겨도 링크가 절대 깨지지 않습니다.
    

#### 2. 2차 방어선(재해 복구용): `xattr` (Extended Attributes)에 UUID 심기

`BookmarkData`도 한계가 있습니다. 타임머신으로 복구하거나, 맥북을 새로 사서 마이그레이션 하면 볼륨 ID가 바뀌면서 `BookmarkData`가 무용지물이 될 수 있습니다. 이때를 대비해 **파일 자체에 문신을 새겨야 합니다.**

- **원리:** 파일 시스템의 **확장 속성(xattr)** 영역에 우리 앱만의 태그를 심습니다.
    
    - Key: `com.hooklink.uuid`
        
    - Value: `db-uuid-string` (JSONL에 저장된 ID와 동일)
        
- **복구 시나리오 (Self-Healing):**
    
    1. `BookmarkData`로 파일을 찾으려 했는데 실패했다? (예: 파일이 완전히 다른 디스크로 이동됨)
        
    2. 그때 **Spotlight 엔진(`mdfind`)**을 가동합니다.
        
    3. `mdfind "kMDItemExtendedAttributes == 'com.hooklink.uuid' && kMDItemExtendedAttributes == '찾으려는_UUID'"` 쿼리를 날립니다.
        
    4. OS가 즉시 해당 UUID가 박힌 파일을 찾아냅니다. 경로를 갱신하고 `BookmarkData`를 새로 발급받아 JSONL을 업데이트합니다.
        
- **장점:** 사용자가 파일을 USB에 담아서 다른 맥으로 가져가도, 거기서 HookLink를 켜면 링크가 되살아납니다. (단, 파일 시스템이 xattr를 지원해야 함)
    

---

### 3. Rust 구현 로드맵 (다음 주 할 일)

백엔드를 뜯어고칠 때 이 로직을 순서대로 녹여내시면 됩니다.

**Step 1. 데이터 구조 설계 (JSONL)**

JSON

```
{
  "id": "550e8400-e29b-...",  // UUID
  "title": "기획안.pdf",
  "path": "/Users/kim/Documents/기획안.pdf", // (참고용/Fail-safe용)
  "bookmark_blob": "YnBsaXN0MDDUAQIDBAUGB...", // Base64 인코딩된 BookmarkData (핵심!)
  "tags": ["work", "planning"],
  "created_at": 1700000000
}
```

Step 2. Rust ↔ macOS 연동

Rust에서 순수하게 BookmarkData를 다루긴 어렵습니다. objc2나 swift-rs 같은 크레이트를 써서 macOS의 Foundation 프레임워크를 호출해야 합니다.

- **저장 시:** `path` -> `NSURL` -> `bookmarkData` -> `Base64 String`
- **로드 시:** `Base64 String` -> `bookmarkData` -> `URLByResolvingBookmarkData` -> `path`

Step 3. xattr 처리

Rust에는 xattr 크레이트가 아주 잘 되어 있습니다. 이건 굳이 Swift 안 거치고 Rust에서 바로 쏘면 됩니다.

Rust

```
// Rust 예시 (개념적)
use xattr;

fn stamp_uuid(path: &Path, uuid: &str) -> Result<()> {
    xattr::set(path, "com.hooklink.uuid", uuid.as_bytes())?;
    Ok(())
}
```

---

### 결론: "Hookmark보다 더 끈질긴 앱"

훅마크는 "Alias 기반"이라 마이그레이션 때 링크가 끊어지는 고통이 있습니다. 선생님의 앱이 **"BookmarkData + xattr UUID"** 조합을 쓴다면, 다음과 같이 자신 있게 말할 수 있습니다.

> **"파일을 옮겨도, 이름을 바꿔도, 심지어 새 맥북으로 복원해도. HookLink는 당신의 파일을 다시 찾아냅니다."**

이 **'Self-Healing(자가 치유)'** 기능은 단순한 런처를 넘어 '신뢰할 수 있는 지식 저장소'가 되기 위한 필수 조건입니다. 다음 주 백엔드 작업 시 이 "이중 추적 로직"을 꼭 포함하시길 권장합니다.