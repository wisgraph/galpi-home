방금 논의했던 **"죽은 링크(Dead Link)"** 문제를 해결하는 핵심은 **파일 경로(Path)에 의존하지 않는 "이중 추적 시스템"**입니다.

경로(예: `/Users/me/file.pdf`)는 주소일 뿐입니다. 이사 가면 끝이죠. 그래서 우리는 파일 자체에 **추적기(GPS)**를 달고, 혹시 몰라 **문신(Tattoo)**까지 새기는 방식을 사용하기로 했습니다.

정리하자면 다음과 같습니다.

---

### 🛡️ 1차 방어선: "GPS 추적기" (macOS BookmarkData)

가장 먼저, 그리고 가장 자주 작동하는 메커니즘입니다.

- **방식:** 파일의 경로(String) 대신, macOS가 발급해주는 **`BookmarkData` (바이너리)**를 저장합니다.
    
- **원리:** 이 데이터 안에는 파일의 고유 ID(Inode 번호)와 볼륨 정보가 들어있습니다.
    
- **효과:** 사용자가 파인더에서 파일 이름을 바꾸거나, 폴더를 이리저리 옮겨도 **OS가 알아서 바뀐 위치를 찾아줍니다.** (마치 알리어스처럼 작동합니다.)
    
- **저장법:** Rust에서 이 바이너리를 **Base64 문자열**로 변환해서 JSONL 파일에 저장합니다.
    

### 🚑 2차 방어선: "신분증 문신" (xattr + UUID)

`BookmarkData`도 실패할 때(예: 디스크 포맷 후 복원, 타임머신 마이그레이션 등 볼륨 ID가 바뀔 때) 작동하는 **재해 복구용**입니다.

- **방식:** 파일을 최초 등록할 때, 파일의 **확장 속성(Extended Attributes, xattr)**에 우리 앱만 아는 UUID를 몰래 새겨넣습니다.
    
    - Key: `com.hooklink.uuid`
        
    - Value: `550e8400-e29b...` (DB에 있는 ID와 동일)
        
- **효과:** 링크가 끊어지면, 앱이 Spotlight(`mdfind`)에게 명령합니다. **"야, 몸에 이 UUID 문신 있는 녀석 하드디스크 전체에서 찾아봐."**
    
- **결과:** 파일이 어디에 숨어있든 찾아내서 링크를 다시 연결(Self-Healing)합니다.
    

---

### ⚙️ 로직 흐름도 (Rust 구현 시나리오)

앱이 링크를 클릭했을 때 작동하는 순서입니다.

1. **경로 확인:** 일단 저장된 경로(`/기존/경로/파일.pdf`)에 파일이 있나 봅니다. (가장 빠름)
    
    - 있음? → **성공 (Open)**
        
    - 없음? → **2단계로 이동**
        
2. **BookmarkData 해독:** 저장해둔 `BookmarkData`를 OS에게 던져줍니다. "이 녀석 어디 갔어?"
    
    - OS: "아, 걔 `/새/경로/이름변경.pdf`로 이사 갔어." → **성공 & 경로 업데이트(Self-Healing)**
        
    - OS: "모르겠는데? (Stale)" → **3단계로 이동**
        
3. **UUID 수색 (Spotlight):** 최후의 수단입니다. `mdfind` 쿼리를 날립니다.
    
    - 찾음? → **성공 & 경로/BookmarkData 모두 갱신(Self-Healing)**
        
    - 못 찾음? → 그때 비로소 "파일을 찾을 수 없습니다" 에러 표시.
        

이 방식을 쓰면 **"훅마크보다 훨씬 끈질기게 파일을 추적하는 앱"**이 됩니다. 다음 주 백엔드 작업하실 때 **`BookmarkData` 생성/해석**과 **`xattr` 읽기/쓰기** 이 두 가지 기능을 Rust 모듈로 먼저 만드시면 됩니다.