
# 🏗️ 전체 사이트 구조 (Sitemap Outline)

1. **Hero:** 문제 제기 (영상: 12초 vs 0.5초)
2. **Persona:** 공감 & 유즈케이스 티저
3. **How it Works:** 구체적 기능 시연
4. **Tech & Trust:** 기술적 신뢰 (Rust, Data Sovereignty)
5. **Comparison:** 경쟁사 비교
6. **Pricing:** 가격 정책
7. **FAQ:** 의심 제거

---

# 섹션 1: 히로섹션 문구
### 🎥 비주얼 전략 (공통)

- **레이아웃:** 텍스트가 위, 영상이 아래에 크게 배치되는 구조 (또는 좌측 텍스트, 우측 영상).
- **영상 내용 (Split Screen Video):**
    - **좌측 (The Past):** 마우스가 북마크바를 누르고, 폴더를 열고, 스크롤을 내리느라 바쁜 모습. (화면 톤: 약간 회색조/지루함)
    - **우측 (HookLink):** `Opt+Space` 누르고 `ㄱㅎ` 엔터! 파일이 팍! 뜨는 모습. (화면 톤: 선명하고 빠름)
    - **자막:** 영상 중앙에 **"12s vs 0.5s"** 타이머가 돌아가다가 멈추는 연출.

---

### ✍️ 카피라이팅 옵션

#### 옵션 A. 도발적인 질문형 (Provocative)

> **사용자의 무의식적인 습관(더블클릭)을 지적하여 '뜨끔'하게 만드는 전략입니다.**

- 헤드라인 (H1):
    "아직도 폴더를 더블클릭 하고 계신가요?"
- 서브 헤드라인 (H2):
    마우스는 잠시 내려두세요. 찾고 싶은 파일, 웹사이트, 문서...
    단축키 하나면 0.5초 만에 당신 앞에 나타납니다.
- CTA 버튼:
    [ 0.5초의 속도 경험하기 (무료 다운로드) ]
    macOS Apple Silicon & Intel 지원
- 배지 (Badge):
    ⚡️ Native Rust App | 🇰🇷 한국어 완벽 지원

#### 옵션 B. 직관적인 이득 강조형 (Benefit-First)

> **"그래서 나한테 뭐가 좋은데?"에 대해 '속도'와 '통합'으로 답하는 전략입니다.**

- 헤드라인 (H1):
    "찾지 마세요. 그냥 부르세요."
- 서브 헤드라인 (H2):
    크롬 북마크, 파인더 폴더, 노션 페이지까지.
    흩어진 맥락을 하나의 런처로 연결했습니다. 키보드에서 손을 떼지 마세요.
- CTA 버튼:
    [ 지금 바로 시작하기 (얼리버드 $4.99) ]
    선착순 100명 한정 $2 할인 쿠폰: RUST_POWER
- 배지 (Badge):
    🔒 Data Stays on Your Mac (데이터는 로컬에 안전하게)

#### 옵션 C. 비교 우위 강조형 (Performance)

> **기존 런처나 파인더에 답답함을 느끼는 사람들을 겨냥한 전략입니다.**

- 헤드라인 (H1):
    "마우스보다 10배 빠른 생각의 속도."
- 서브 헤드라인 (H2):
    매년 $70를 내야 하는 복잡한 도구는 잊으세요.
    가볍고, 빠르고, 평생 소장 가능한 가장 미니멀한 맥락 런처입니다.
- CTA 버튼:
    [ 무료로 체험해보기 ]
    읽기/검색 기능 평생 무료

---

### 💡 추천 조합 및 디테일

개인적으로는 **[옵션 A 헤드라인] + [옵션 B 서브헤드라인]** 조합을 강력 추천합니다.

**최종 제안 (Final Draft):**

> **(Badge: 🚀 100% Native Rust App)**
> 
> # **아직도 폴더를 더블클릭 하고 계신가요?**
> 
> ### 마우스는 잠시 내려두세요. 크롬 북마크부터 깊숙한 PDF 파일까지.
> 
> ### **HookLink**는 당신이 찾는 모든 것을 0.5초 만에 눈앞에 가져옵니다.
> 
> [ 무료로 시작하기 ] [ 얼리버드 구매 ($4.99) ]
> 
> macOS v12+ | Apple Silicon Optimized

---

### 🛠 히로 섹션에 꼭 넣어야 할 "한 끗" (Tip)

영상 바로 아래나 버튼 주변에 **"신뢰 장치(Trust Signal)"** 를 한 줄 넣어주세요. 인디 앱의 의심을 지워줍니다.

- _"내 데이터는 내 컴퓨터에. 클라우드에 전송되지 않는 투명한 텍스트 저장 방식."_
- _"No Subscription. Pay once, use forever."_ (구독 없음. 한 번 구매로 평생 소장.)

이 문구로 히로 섹션을 확정하고, 다음 섹션(기능 소개/비교)으로 넘어가시겠습니까?

# 섹션 2: 페르소나 
### 🏗 섹션 전략: "당신의 워크플로우, 어디에서 막히고 있나요?"

단순히 직업군을 나누는 것이 아니라, 그들이 겪는 **'구체적인 고통(Pain Point)'** 을 묘사하고, HookLink가 그것을 **'쾌감'** 으로 바꾸는 순간을 보여줍니다.

- **레이아웃:** 4개의 탭(Tab) 또는 그리드 카드 형태
    
- **헤드라인:** **"누구나 자신만의 '연결'이 필요합니다."**

---

#### 👤 페르소나 1: The PKM Architect (옵시디언/노션 사용자)

> **타겟:** 지식 관리에 진심이지만, 파일과 노트의 단절 때문에 괴로운 사람들. (사용자님의 핵심 타겟)

- **Pain Point (Before):**
    > "옵시디언 그래프는 아름답지만, 정작 중요한 PDF 원본과 엑셀 파일은 파인더 어딘가에 고립되어 있습니다. 노트와 파일이 따로 노는 '반쪽짜리 세컨드 브레인'을 쓰고 계시진 않나요?"
    
- **HookLink Solution (After):** *"노트와 파일을 잇는 가장 강력한 마크다운 접착제."* 
    > - **Instant MOC:** `#프로젝트A` 태그로 검색된 파일 20개를 한 번에 복사하세요. 옵시디언에 붙여넣으면, 순식간에 **'파일 인덱스 페이지'** 가 완성됩니다.      
    > - **Plain Text First:** 우리는 당신의 데이터를 가두지 않습니다. `[파일이름](hook://uuid)` 형태의 순수 텍스트 링크로 당신의 볼트(Vault)를 완성하세요.      

#### 👤 페르소나 2: The Deep Diver (연구자/대학원생)

> **타겟:** 논문(PDF)과 참고문헌의 늪에서 허우적대는 사람들. 2

- **Pain Point (Before):**
    > "논문을 읽다가 중요한 문구를 발견했습니다. 그런데 일주일 뒤, 그 문구가 '어느 논문, 몇 페이지'에 있었는지 기억나시나요? 다시 찾느라 30분을 낭비하고 계신가요?" 3
    
- **HookLink Solution (After):** *"페이지를 넘어, 문단까지 기억합니다."*
    > - **Deep PDF Linking:** 단순한 파일 열기가 아닙니다. 링크를 누르면 **PDF의 34페이지, 3번째 문단**이 하이라이트 된 채로 열립니다. 4* **Zotero의 단짝:** Zotero 서지 정보와 내 컴퓨터 속 PDF, 그리고 작성 중인 스크리브너 원고를 하나의 맥락으로 묶으세요. 5 
    

#### 👤 페르소나 3: The Context Switcher (개발자/디자이너)

> **타겟:** 창 전환 비용과 맥락 손실에 민감한 기술 인력. 6

- **Pain Point (Before):**
    > "코드는 짰는데, '왜' 이렇게 짰는지 기억이 안 납니다. 기획서(Jira), 디자인(Figma), 코드(VS Code)가 다 따로 놀기 때문이죠. 이 셋을 확인하느라 창을 5번씩 오갑니다." 
    
- **HookLink Solution (After):** *"IDE를 벗어나지 않는 맥락의 연결."* 
    > - **Intent Linking:** 코드 주석에 HookLink를 남기세요. 클릭 한 번으로 해당 코드의 **기획 의도가 담긴 슬랙 스레드**나 **피그마 시안**이 뜹니다. 
    > - **No Electron Lag:** 이 모든 과정에 메모리는 거의 들지 않습니다. Rust로 짜인 네이티브 앱이니까요.
    

#### 👤 페르소나 4: The Project Lead (법조인/PM/기획자)

> **타겟:** 마감 기한과 수많은 증거/참고 자료를 다루는 전문직. 9

- **Pain Point (Before):**
    
    > "회의 시작 3분 전. '그때 그 메일'과 첨부파일, 지난 회의록을 찾느라 식은땀을 흘립니다. 파일을 정리하는 것보다 찾는 게 더 일이 되어버렸습니다." 10
    
- **HookLink Solution (After):**
    
    > **"모든 자료를 '사건' 중심으로 재편합니다."**
    > 
    > - **Project Hub:** 이메일, 계약서, 슬랙 메시지... 형식이 달라도 상관없습니다. 같은 태그(`#Case_204`)만 붙여두면, 런처에서 엔터 한 번으로 모든 관련 자료가 소환됩니다. 11
    >     
    > - **Self-Healing:** 파일을 다른 폴더로 옮기셨나요? 걱정 마세요. HookLink가 끝까지 추적해서 연결을 유지합니다. 12
    >     
    

---

### 💡 추가 아이디어: "기능적 차별점"을 페르소나에 녹이기

사용자님이 말씀하신 **"일괄 복사(Bulk Copy)"** 기능을 단순히 기능 설명이 아니라, **"Obsidian 유저의 꿈을 이뤄주는 도구"** 로 포지셔닝하는 카피를 제안합니다.

**[Feature Highlight Section - For PKM Users]**

> [!note] **"대시보드를 만드는 가장 빠른 방법"**
> 
> 1. HookLink 런처에서 `#인공지능` 태그 검색
> 2. `Cmd + Shift + C` (검색 결과 전체 링크 복사)
> 3. Obsidian에 `Cmd + V`
> 
> 결과: 순식간에 30개의 관련 파일과 웹사이트가 정리된 [인공지능 MOC] 페이지가 생성됩니다.
> 수동으로 링크 걸던 노가다는 이제 그만하세요.


## 상세 유즈케이스 페이지 구성

페이지 제목: HookLink Use Cases

전략: [상황(Hell) -> 해결(Heaven) -> 방법(How-to)] 3단 구성으로 "나도 저렇게 쓰고 싶다"는 욕구를 자극합니다.

#### **Case 1. 옵시디언(Obsidian) & 노션 유저를 위한 "완벽한 연결"**

> _가장 강력한 타겟층이므로 최상단에 배치_
- The Pain (Before): "옵시디언에 글을 쓸 때 가장 귀찮은 건 외부 파일을 연결하는 겁니다. 파인더를 열고, 파일을 찾고, 경로를 복사하고... 파일 위치를 옮기면 링크는 깨져버리죠. 결국 노트 따로, 파일 따로 놀게 됩니다."
- The HookLink Way (After): "HookLink는 파일과 웹사이트를 '마크다운 텍스트'로 변환해 줍니다. 파인더의 파일들을 선택하고 단축키 한 번만 누르세요. 옵시디언에 붙여넣으면 끝입니다. 파일이 어디로 이동하든, 링크는 깨지지 않습니다."
- **⚡️ Killer Feature (MOC 만들기):**
    1. HookLink 런처에서 `#인공지능` 검색 (관련 논문/웹사이트 20개 검색됨)
    2. `Cmd + Shift + C` (전체 마크다운 링크 복사)
    3. 옵시디언에 `Cmd + V`
    4. **결과:** 1초 만에 **'인공지능 자료 모음(MOC)'** 노트 완성.

#### **Case 2. 연구자를 위한 "Deep PDF Linking"**

> _딥리서치 자료 반영: Zotero, Scrivener 사용자 겨냥_
- The Pain (Before): "논문 A의 45페이지 표 3을 인용하고 싶은데, 나중에 다시 찾으려면 PDF를 열고 스크롤을 한참 내려야 합니다. '참고문헌' 폴더는 이미 엉망진창입니다."
- The HookLink Way (After): "파일을 여는 게 아니라, 지식을 엽니다. PDF를 읽다가 중요한 부분에 HookLink를 거세요. 나중에 링크를 클릭하면, PDF 뷰어가 켜짐과 동시에 정확히 그 페이지, 그 문단으로 이동합니다. 스크리브너(Scrivener) 집필 중에도 흐름이 끊기지 않습니다."
- **💡 Tip:** Zotero 서지 정보와 PDF 원본 파일을 HookLink로 묶어두면 연구 효율이 2배 오릅니다.

#### **Case 3. 개발자를 위한 "No Context Switching"**

> _Rust 기반 성능 강조_
- The Pain (Before): "구현해야 할 기능 명세서(Jira), 디자이너의 코멘트(Figma), 그리고 API 문서(Web). 코딩하다 말고 이 창 저 창 찾느라 Cmd+Tab만 수십 번 누릅니다. 그러다 집중력(Flow)이 깨집니다."
- The HookLink Way (After): "IDE에서 나가지 마세요. 코드 주석에 hook://ticket/123 링크를 남기세요. 클릭 한 번이면 필요한 기획서가 팝업으로 뜹니다. Electron이 아닌 Native Rust 앱이라, 당신의 소중한 메모리는 오직 컴파일러에게만 양보합니다."

---

### 3. 페이지 하단: 강력한 마무리 (CTA)

유즈케이스 페이지를 다 읽은 사람은 이미 설득된 상태입니다. 바로 구매로 이어지게 하세요.
- **Copy:** **"당신의 워크플로우에 '연결'을 더하세요."**
- **Sub:** **지금 얼리버드 $4.99에 평생 소장하세요. (선착순 100명)**
- **Button:** [ **HookLink 시작하기 (Beta)** ]


# 섹션 3: How it Works (기능 시연)

**목표:** "너무 쉬워서 배우는 데 10초도 안 걸린다"는 것을 증명. 복잡한 훅마크와의 차별점입니다.
- **헤드라인:** **"복잡한 설정은 잊으세요. 딱 3단계면 됩니다."**
- **레이아웃:** 가로 스크롤 또는 1-2-3 단계별 스텝 (Step) 구성.

#### Step 1. Capture (저장)
- **Copy:** **"지금 보는 그 화면, 그대로 캡처."**
- **Desc:** 웹사이트, PDF, 이메일... 창을 전환할 필요 없습니다. 단축키 한 번이면 현재 맥락(Context)이 런처에 담깁니다.
- **Visual:** 크롬을 보다가 런처를 띄워 엔터 치는 움짤.

#### Step 2. Tag (정리)
- **Copy:** **"폴더 고민 끝, 태그로 툭."**
- **Desc:** "어느 폴더에 넣지?" 고민하지 마세요. `#프로젝트A`, `#참고자료` 태그만 툭 던져두세요. 파일은 제자리에, 정리는 HookLink에.
- **Visual:** 런처에서 태그 입력 시 자동완성 되는 모습.

#### Step 3. Recall (소환)
- **Copy:** **"개떡같이 말해도 찰떡같이 찾습니다."**
- **Desc:** 정확한 파일명이 기억 안 나시나요? 초성(`ㄱㅎ`), 태그, 키워드 무엇이든 입력하세요. 0.1초 만에 찾아냅니다.
- **Visual:** `ㅁㅋ` 입력 -> `마케팅 기획안.pdf`가 최상단에 뜨는 모습.

---

# 섹션 4: Tech & Trust (기술적 신뢰 - 킬러 섹션)

**목표:** Rust 기반의 성능과 '데이터 주권'을 강조하여 개발자와 파워 유저를 매료시킵니다.
- **헤드라인:** **"가볍지만, 가장 튼튼한 금고."**
- **레이아웃:** 좌측(설명) / 우측(코드나 JSON 파일이 보이는 이미지)

#### Point 1. Native Performance (Rust)
- **Copy:** **메모리 도둑(Electron)을 쫓아냈습니다.**
- **Desc:** HookLink의 주요 로직은 **Rust**로 구성됩니다. 메모리 점유율 100MB 미만. 당신의 맥북 팬(Fan)은 이제 조용해질 겁니다.

#### Point 2. Future-Proof Data (JSONL)
- **Copy:** **데이터를 인질로 잡지 않습니다.**
- **Desc:** 알 수 없는 암호화 DB가 아닙니다. 모든 링크는 내 문서 폴더의 **투명한 텍스트 파일(JSON)** 로 저장됩니다. 메모장으로 열 수 있고, 깃(Git)으로 백업할 수도 있습니다.
- **Badge:** `No Vendor Lock-in`

#### Point 3. Self-Healing Links
- **Copy:** **파일이 도망가도 끝까지 추적합니다.**
- **Desc:** 파일 이름을 바꾸거나 폴더를 옮겨도 링크는 깨지지 않습니다. macOS의 심층 파일 시스템(Inode)을 추적하여 끊어진 연결을 스스로 복구합니다.

## Technology Deep Dive **(개발자, 파워유저, 기존 앱 이탈자를 위한 상세 페이지)**

### The Architecture of HookLink - ==Why we ditched the Graph DB for Sets and Rust.==

---

#### 챕터 1. The Core Philosophy: "Sets over Graphs"

**(양방향 링크의 한계를 태그로 극복한다는 논리)**

> **"왜 우리는 '양방향 링크' 테이블을 버렸는가?"**

기존의 연결 도구들은 **'파일 A'와 '파일 B'를 잇는 다리(Link Table)** 를 만듭니다. 파일이 100개가 되면, 다리는 수천 개가 필요합니다. 이 방식은 무겁고, 하나만 끊어져도 맥락이 사라집니다.

HookLink는 **'집합(Set)'** 을 사용합니다.

- **방식:** 당신이 **[#2026_기획]** 이라는 맥락(Context)을 켜두면, 이후 등록하는 웹사이트, PDF, 문서는 자동으로 **[#2026_기획]** 집합의 원소가 됩니다.
- **결과:** A와 B를 연결할 필요가 없습니다. 그들은 이미 같은 집합에 속해 있으니까요. 언제든 `#2026_기획`을 호출하면, 관련된 모든 파일이 양방향으로 연결된 것처럼 나타납니다.
- **장점:**
    - **Zero Friction:** 링크를 걸기 위해 팝업을 띄울 필요가 없습니다. 그냥 저장하세요.
    - **Auto-Context:** 런처가 현재 활성화된 맥락을 기억하고, 태그를 자동으로 입력해 줍니다.

#### 챕터 2. The Engine: "Rust, not Scripts"

**(기존 앱의 기술적 페인포인트를 간접 저격)**

> **"스크립트 떡칠(Glue Code)에서 벗어나다."**

많은 맥용 생산성 도구들이 수백 개의 AppleScript에 의존해 작동합니다. 그래서 크롬이 업데이트되면 앱이 멈추고, 파인더가 느려지면 앱도 느려집니다.

- **Rust Native:** HookLink는 시스템 레벨 언어인 Rust로 작성되었습니다.
    - **Memory Safe:** Electron 앱(200MB+)의 1/10 수준인 메모리 점유율.
    - **Concurrency:** 수만 개의 링크 검색도 `Tokio` 비동기 런타임 위에서 0.05초 안에 끝납니다.
- **Direct API:** 스크립트를 거치지 않고, macOS Accessibility API와 직접 통신하여 가장 빠른 반응 속도를 보장합니다.

#### 챕터 3. Data Sovereignty: "JSONL Storage"

**(DB 깨짐 문제 해결 & 데이터 주권)**

> **"당신의 데이터는 당신이 읽을 수 있어야 합니다."**

소프트웨어가 업데이트되다가 DB가 깨져서(Corruption) 데이터를 날린 경험이 있으신가요? 혹은 앱을 지웠더니 내 데이터도 인질처럼 잠겨버린 적은요?

- **Human Readable:** HookLink의 저장소는 평범한 텍스트 파일(`data.jsonl`)입니다.
- **Corruption Proof:** 데이터베이스 엔진이 깨질 일이 없습니다. 텍스트 파일은 언제나 안전하며, 충돌이 발생해도 사람이 직접 수정하거나 병합(Merge)할 수 있습니다.
- **Git Friendly:** 텍스트 기반이기에 깃(Git)으로 버전을 관리하거나 백업하기 최적화되어 있습니다.

#### 챕터 4. Resilience: "The Dual-Tracking System"

**(링크 유실 문제 해결)**

> **"파일이 도망가도 끝까지 쫓아갑니다."**

단순히 파일 경로(Path)만 저장하는 것은 아마추어 방식입니다. HookLink는 macOS의 심층 기능을 활용해 **이중 추적 시스템**을 가동합니다.

1. **BookmarkData:** 파일 시스템의 고유 ID(Inode)를 추적합니다. 파인더에서 파일 이름을 바꾸거나 폴더를 옮겨도, HookLink는 바뀐 경로를 즉시 알아냅니다.
2. **Xattr UUID:** 최악의 경우(디스크 포맷 후 복원 등)를 대비해, 파일 자체에 보이지 않는 디지털 문신(Extended Attribute)을 새겨 넣습니다. 스포트라이트 엔진이 지구 끝까지 쫓아가 파일을 다시 연결합니다.

---

#### 하단 섹션: For Developers (신뢰 구축)

- **Open Adapter:** (향후 지원 예정) "우리의 연동 로직은 투명하게 공개될 것입니다. 당신만의 워크플로우를 직접 코딩하세요."
- **No Telemetry:** "우리는 당신이 어떤 파일을 여는지 추적하지 않습니다. 서버로 전송되는 데이터는 '라이선스 인증 키' 단 하나뿐입니다."

---

#### 💡 전략적 포인트

이 기술 페이지는 단순히 "잘 만들었다"를 자랑하는 곳이 아닙니다.
기존 훅마크 사용자들이 겪었던 

① DB 깨짐, 
② 스크립트 오류로 인한 먹통, 
③ 복잡한 링크 관리의 스트레스를 **"우리는 구조적으로 그 문제가 발생할 수 없다"** 

라고 안심시키는 **'치유의 공간'** 입니다.

이 내용으로 기술 페이지의 뼈대를 잡고, 홈페이지 섹션 4는 호기심을 자극하는 예고편으로 배치하면 완벽할 것 같습니다. 진행할까요?

### 디비를 제거하자

```
Items      | JSON File Size (MB)  | Est. Rust RAM (MB)  
------------------------------------------------------------
10000      | 2.54                 | 3.91                
100000     | 25.37                | 39.10               
500000     | 126.84               | 195.50              
1000000    | 253.68               | 391.01              
```

결론부터 말씀드리면, **"전혀 걱정하실 필요가 없습니다."**

선생님이 선택하신 언어가 **Rust**이기 때문에 가능한 이야기입니다. 만약 Electron(자바스크립트)이나 Java로 만드셨다면 메모리 누수나 가비지 컬렉션 때문에 멈칫거렸겠지만, Rust에서는 **데이터 10만 개를 메모리에 통째로 올려도 40~50MB 수준**에 불과합니다.

제가 가상의 시나리오(링크 1개당 URL, 제목, 태그 3개 포함)로 시뮬레이션을 돌려본 결과는 다음과 같습니다.

#### 📊 데이터 규모별 메모리 점유율 예측 (Rust 기준)

|**사용자 유형**|**링크 개수**|**JSON 파일 크기**|**예상 메모리 점유율**|**비고**|
|---|---|---|---|---|
|**일반 유저**|10,000개|약 2.5 MB|**약 4 MB**|스포티파이 노래 한 곡 용량도 안 됨|
|**헤비 유저**|100,000개|약 25 MB|**약 40 MB**|크롬 탭 1개보다 가벼움|
|**익스트림**|1,000,000개|약 250 MB|**약 390 MB**|100만 개를 모으는 사람은 거의 없음|

요즘 맥북 기본 램이 8GB~16GB인 점을 감안하면, **헤비 유저라도 시스템에 아무런 영향을 주지 않는 수준**입니다.

---

#### 💡 추천 아키텍처: "JSONL + In-Memory"

SQLite의 복잡함을 버리고, **속도와 투명성**을 모두 잡는 가장 현대적인 구조를 제안합니다.

##### 1. 저장 포맷: `JSONL` (Line-delimited JSON)

일반 JSON은 파일 전체가 하나의 `[]` 리스트라 수정할 때마다 파일 전체를 다시 써야 해서 느립니다. 대신 **JSONL**을 쓰세요.

- **구조:** 한 줄에 JSON 객체 하나씩.
- **추가(Write):** 파일 맨 끝에 한 줄만 덧붙이면 끝 (`O(1)`). 엄청나게 빠릅니다.
- **투명성:** 사용자가 텍스트 에디터로 열어서 직접 고칠 수도 있습니다.

##### 2. 실행 전략: "Full Load at Startup"

- **앱 켤 때:** `JSONL` 파일을 싹 읽어서 Rust의 `HashMap`이나 `Vec` 구조체로 메모리에 올립니다.
- **속도:** Rust의 `serde_json`은 초당 수백 MB를 처리합니다. 10만 개(25MB) 읽는 데 **0.1초도 안 걸립니다.**
- **검색:** 메모리에 다 있으니 `Fuzzy Search`를 하든 태그 필터링을 하든 **반응 속도가 '제로(Zero Latency)'**에 가깝습니다. 디스크를 긁지 않으니까요.

##### 3. 메모리 최적화 팁 (더 가볍게 만들고 싶다면)

혹시라도 메모리가 걱정된다면, Rust에서 **`String Interning`** 기법을 쓰세요.
- **상황:** 링크 1만 개에 전부 `#design`이라는 태그가 달려있다고 칩시다. 이걸 무식하게 저장하면 "design"이라는 글자만 1만 번 저장됩니다.
- **해결:** "design"은 메모리에 딱 한 번만 저장하고, 나머지는 **숫자 ID(u32)** 로 가리키게 만듭니다. 이렇게 하면 메모리 사용량을 획기적으로(절반 이하로) 줄일 수 있습니다.

#### ✅ 결론

**"디비를 버리셔도 됩니다."**

복잡한 SQLite 관리 코드, 마이그레이션 이슈, VACUUM 처리... 다 잊으시고 심플하게 **텍스트 파일(JSONL)**로 가세요.

사용자에겐 이렇게 어필하면 됩니다.

> **"HookLink는 당신의 데이터를 암호화된 DB에 가두지 않습니다. 당신의 모든 기록은 평범한 텍스트 파일로 저장되며, 당신이 100% 소유합니다. 그런데도 훅마크보다 빠르죠. Rust니까요."**

### 디비 없을때 주의할 점

**"메모리"보다는 "데이터 안전성(Safety)"과 "동시성(Concurrency)"에서 문제가 발생할 확률이 높습니다.**

JSONL + In-Memory 방식은 속도와 투명성 면에서 탁월하지만, 데이터베이스(SQLite 등)가 알아서 해주던 '안전장치'들을 개발자가 직접 구현해야 한다는 부담이 있습니다.

놓치기 쉬운 치명적인 문제점 4가지와 그에 대한 **Rust 기반 해결책**을 정리해 드립니다.

---

#### 1. 동시 쓰기 문제 (Race Condition) - 가장 위험! ⚠️

- **상황:** 만약 선생님의 앱이 실행되는 도중, 백그라운드 워커(예: 파일 감시자)나 사용자가 켠 또 다른 인스턴스가 동시에 `data.jsonl` 파일에 쓰기를 시도한다면?
- **문제:** 파일 내용이 뒤섞이거나(Corrupted), 마지막 데이터가 날아갑니다. JSON 구조가 깨져서 앱이 다음 실행 때 켜지지도 않을 수 있습니다.
- **해결책 (Rust):**
    - **File Locking:** `fs2` 크레이트 등을 사용하여 파일에 접근할 때 **OS 레벨의 락(Lock)**을 걸어야 합니다. 다른 프로세스가 접근 못 하게 막아야 합니다.
    - **Actor Model:** 쓰기 작업은 오직 **하나의 스레드(Actor)**만 담당하게 하세요. (`mpsc` 채널을 통해 "저장해줘" 메시지만 보내고, 실제 파일 쓰기는 그놈 혼자서 순서대로 처리.)

#### 2. "쓰다가 죽었을 때" (Atomicity)

- **상황:** 데이터를 저장하는 0.01초 사이에 노트북 배터리가 나가거나 앱이 강제 종료된다면?
- **문제:** `data.jsonl`의 마지막 줄이 `{ "id": "uuid", "tit...` 처럼 잘린 채로 저장됩니다. 다음 부팅 때 `serde_json`이 파싱 에러를 뿜으며 앱이 뻗어버립니다.
- **해결책:**
    - **Atomic Write:** (파일 전체를 다시 쓸 경우) 임시 파일(`temp.jsonl`)에 먼저 다 쓰고, 성공하면 원본 파일로 이름만 바꿉니다(`rename`). 이는 OS 레벨에서 원자적(Atomic)이라 안전합니다.
    - **Append Only일 경우:** 마지막 줄이 깨져도 전체 데이터를 날리지 않도록, 로딩할 때 **"에러가 난 줄(Line)은 무시하고 로그를 남긴 뒤 넘어가는(Skip & Log)"** 로직을 반드시 넣어야 합니다. (`unwrap()` 금지!)

#### 3. 클라우드 동기화 충돌 (iCloud/Dropbox Conflict)

- **상황:** 사용자가 사무실 맥에서 작업하고(집 맥이 켜진 상태), 집에 와서 다시 작업할 때.
- **문제:** 드롭박스 같은 클라우드 스토리지는 텍스트 파일이 양쪽에서 바뀌면 `data (Conflicted Copy).jsonl` 같은 파일을 만들어버립니다. 앱은 이걸 못 읽습니다.
- **해결책:**
    - 이건 파일 기반 앱의 숙명입니다. (옵시디언도 겪는 문제)
    - **완화법:** 앱 시작 시 파일 변경 시간(Modified Time)을 체크해서 외부에서 파일이 바뀌었으면 메모리를 다시 로드(Reload)하는 기능이 필요합니다.

#### 4. 초기 로딩 속도 (Startup Latency)

- **상황:** 데이터가 10만 개가 넘어가면, 아무리 빨라도 텍스트 파싱에 200~500ms 정도 걸릴 수 있습니다.
- **문제:** 사용자는 런처가 "즉시" 뜨길 원합니다. 0.5초의 딜레이도 둔하게 느껴집니다.
- **해결책:**
    - **비동기 로딩 (Async Loading):** UI(검색창)는 즉시 띄우고, 데이터 로딩은 백그라운드(`tokio::spawn`)에서 하세요.
    - 로딩이 덜 됐을 때 검색하면 "로딩 중..." 스피너를 보여주면 됩니다. 체감 성능은 0초가 됩니다.

---

#### 📝 종합 처방전 (Architecture Checklist)

이 방식을 고수하시려면, 코드 설계 시 다음 3가지를 꼭 지키세요.

1. **Strict Serialization:**
    - 쓰기 전담 스레드(Single Writer Thread)를 만드세요. 아무나 파일에 접근하게 두지 마세요.
2. **Graceful Error Handling:**
    - `data.jsonl`을 한 줄씩 읽을 때, 파싱 에러가 나면 **절대 패닉(Panic)하지 말고**, 그 줄만 버린 후 나머지 데이터를 살리세요.
3. **Atomic Save Strategy:**
    - 데이터 양이 적을 땐(1만 개 이하), `Append`보다 그냥 전체 덤프(Atomic Write)가 더 안전하고 관리하기 쉽습니다.

#### 결론:  메모리 부족(OOM)은 걱정 안 하셔도 됩니다.

진짜 적은 **"파일 깨짐"** 입니다. 이 부분만 방어 로직을 튼튼하게 짜신다면, SQLite보다 훨씬 매력적인(투명하고 빠른) 앱이 될 것입니다.

백엔드를 **Rust + JSONL + In-Memory**로 완전히 개편하면서, 가장 골치 아픈 **"링크 유실(Link Rot)"** 문제(파일 이동, 이름 변경, 백업 복구 시 링크 깨짐)를 해결할 수 있는 **이중 안전장치 전략**을 제안합니다.

### 전략: "BookmarkData" + "xattr(확장 속성)"의 하이브리드 추적

디비(JSONL)에는 파일의 '위치 정보'를 저장하고, 파일 자체에는 '신분증(UUID)'을 심어놓는 방식입니다.

#### 1. 1차 방어선: macOS `BookmarkData` (aka. Security Scoped Bookmark)

단순히 파일 경로(`/Users/me/doc.pdf`)를 저장하면 안 됩니다. macOS API가 제공하는 **`BookmarkData`**를 사용해야 합니다.

- **원리:** macOS의 `URL.bookmarkData(options:...)` API를 호출하면, 해당 파일의 고유한 바이너리 데이터(Blob)를 줍니다. 이 데이터 안에는 **파일 ID(Inode), 볼륨 ID, 파일 경로**가 모두 암호화되어 들어있습니다.
- **구현 방법 (Rust + JSONL):**
    1. 사용자가 파일을 링크할 때, Swift/Obj-C 브릿지를 통해 `BookmarkData`를 생성합니다.
    2. 이 바이너리 데이터를 **Base64 문자열**로 인코딩해서 JSONL의 `bookmark` 필드에 저장합니다.
    3. **추적:** 나중에 앱에서 링크를 열 때, 경로가 아니라 이 `BookmarkData`를 먼저 해석(Resolve)합니다. 파일 이름이 바뀌거나 폴더가 이동되어도 OS가 "아, 그 파일 여기로 갔어" 하고 새 경로를 찾아줍니다.
- **장점:** 파인더에서 파일을 이리저리 옮겨도 링크가 절대 깨지지 않습니다.

#### 2. 2차 방어선(재해 복구용): `xattr` (Extended Attributes)에 UUID 심기

`BookmarkData`도 한계가 있습니다. 타임머신으로 복구하거나, 맥북을 새로 사서 마이그레이션 하면 볼륨 ID가 바뀌면서 `BookmarkData`가 무용지물이 될 수 있습니다. 이때를 대비해 **파일 자체에 문신을 새겨야 합니다.**

- **원리:** 파일 시스템의 **확장 속성(xattr)** 영역에 우리 앱만의 태그를 심습니다.
    - Key: `com.hooklink.uuid`
    - Value: `db-uuid-string` (JSONL에 저장된 ID와 동일)
- **복구 시나리오 (Self-Healing):**
    1. `BookmarkData`로 파일을 찾으려 했는데 실패했다? (예: 파일이 완전히 다른 디스크로 이동됨)
    2. 그때 **Spotlight 엔진(`mdfind`)**을 가동합니다.
    3. `mdfind "kMDItemExtendedAttributes == 'com.hooklink.uuid' && kMDItemExtendedAttributes == '찾으려는_UUID'"` 쿼리를 날립니다.
    4. OS가 즉시 해당 UUID가 박힌 파일을 찾아냅니다. 경로를 갱신하고 `BookmarkData`를 새로 발급받아 JSONL을 업데이트합니다.
- **장점:** 사용자가 파일을 USB에 담아서 다른 맥으로 가져가도, 거기서 HookLink를 켜면 링크가 되살아납니다. (단, 파일 시스템이 xattr를 지원해야 함)

---

#### 3. Rust 구현 로드맵 (다음 주 할 일)

백엔드를 뜯어고칠 때 이 로직을 순서대로 녹여내시면 됩니다.

**Step 1. 데이터 구조 설계 (JSONL)**

```json
{
  "id": "550e8400-e29b-...",  // UUID
  "title": "기획안.pdf",
  "path": "/Users/kim/Documents/기획안.pdf", // (참고용/Fail-safe용)
  "bookmark_blob": "YnBsaXN0MDDUAQIDBAUGB...", // Base64 인코딩된 BookmarkData (핵심!)
  "tags": ["work", "planning"],
  "created_at": 1700000000
}
```

**Step 2. Rust ↔ macOS 연동**

Rust에서 순수하게 BookmarkData를 다루긴 어렵습니다. objc2나 swift-rs 같은 크레이트를 써서 macOS의 Foundation 프레임워크를 호출해야 합니다.

- **저장 시:** `path` -> `NSURL` -> `bookmarkData` -> `Base64 String`
- **로드 시:** `Base64 String` -> `bookmarkData` -> `URLByResolvingBookmarkData` -> `path`

**Step 3. xattr 처리**

Rust에는 xattr 크레이트가 아주 잘 되어 있습니다. 이건 굳이 Swift 안 거치고 Rust에서 바로 쏘면 됩니다.

```rust
// Rust 예시 (개념적)
use xattr;

fn stamp_uuid(path: &Path, uuid: &str) -> Result<()> {
    xattr::set(path, "com.hooklink.uuid", uuid.as_bytes())?;
    Ok(())
}
```

---

#### 결론: "Hookmark보다 더 끈질긴 앱"

훅마크는 "Alias 기반"이라 마이그레이션 때 링크가 끊어지는 고통이 있습니다. 선생님의 앱이 **"BookmarkData + xattr UUID"** 조합을 쓴다면, 다음과 같이 자신 있게 말할 수 있습니다.

> **"파일을 옮겨도, 이름을 바꿔도, 심지어 새 맥북으로 복원해도. HookLink는 당신의 파일을 다시 찾아냅니다."**

이 **'Self-Healing(자가 치유)'** 기능은 단순한 런처를 넘어 '신뢰할 수 있는 지식 저장소'가 되기 위한 필수 조건입니다. 다음 주 백엔드 작업 시 이 "이중 추적 로직"을 꼭 포함하시길 권장합니다.
방금 논의했던 **"죽은 링크(Dead Link)"** 문제를 해결하는 핵심은 **파일 경로(Path)에 의존하지 않는 "이중 추적 시스템"**입니다.

---

### 이중 추적 시스템

경로(예: `/Users/me/file.pdf`)는 주소일 뿐입니다. 이사 가면 끝이죠. 그래서 우리는 파일 자체에 **추적기(GPS)**를 달고, 혹시 몰라 **문신(Tattoo)**까지 새기는 방식을 사용하기로 했습니다.

정리하자면 다음과 같습니다.

#### 🛡️ 1차 방어선: "GPS 추적기" (macOS BookmarkData)

가장 먼저, 그리고 가장 자주 작동하는 메커니즘입니다.
- **방식:** 파일의 경로(String) 대신, macOS가 발급해주는 **`BookmarkData` (바이너리)** 를 저장합니다.
- **원리:** 이 데이터 안에는 파일의 고유 ID(Inode 번호)와 볼륨 정보가 들어있습니다.
- **효과:** 사용자가 파인더에서 파일 이름을 바꾸거나, 폴더를 이리저리 옮겨도 **OS가 알아서 바뀐 위치를 찾아줍니다.** (마치 알리어스처럼 작동합니다.)
- **저장법:** Rust에서 이 바이너리를 **Base64 문자열**로 변환해서 JSONL 파일에 저장합니다.

#### 🚑 2차 방어선: "신분증 문신" (xattr + UUID)

`BookmarkData`도 실패할 때(예: 디스크 포맷 후 복원, 타임머신 마이그레이션 등 볼륨 ID가 바뀔 때) 작동하는 **재해 복구용**입니다.
- **방식:** 파일을 최초 등록할 때, 파일의 **확장 속성(Extended Attributes, xattr)**에 우리 앱만 아는 UUID를 몰래 새겨넣습니다.
    - Key: `com.hooklink.uuid`
    - Value: `550e8400-e29b...` (DB에 있는 ID와 동일)
- **효과:** 링크가 끊어지면, 앱이 Spotlight(`mdfind`)에게 명령합니다. **"야, 몸에 이 UUID 문신 있는 녀석 하드디스크 전체에서 찾아봐."**
- **결과:** 파일이 어디에 숨어있든 찾아내서 링크를 다시 연결(Self-Healing)합니다.

#### ⚙️ 로직 흐름도 (Rust 구현 시나리오)

앱이 링크를 클릭했을 때 작동하는 순서입니다.
1. **경로 확인:** 일단 저장된 경로(`/기존/경로/파일.pdf`)에 파일이 있나 봅니다. (가장 빠름)
    - 있음? → **성공 (Open)**
    - 없음? → **2단계로 이동**
2. **BookmarkData 해독:** 저장해둔 `BookmarkData`를 OS에게 던져줍니다. "이 녀석 어디 갔어?"
    - OS: "아, 걔 `/새/경로/이름변경.pdf`로 이사 갔어." → **성공 & 경로 업데이트(Self-Healing)**
    - OS: "모르겠는데? (Stale)" → **3단계로 이동**
3. **UUID 수색 (Spotlight):** 최후의 수단입니다. `mdfind` 쿼리를 날립니다.
    - 찾음? → **성공 & 경로/BookmarkData 모두 갱신(Self-Healing)**
    - 못 찾음? → 그때 비로소 "파일을 찾을 수 없습니다" 에러 표시.

이 방식을 쓰면 **"훅마크보다 훨씬 끈질기게 파일을 추적하는 앱"** 이 됩니다. 다음 주 백엔드 작업하실 때 **`BookmarkData` 생성/해석**과 **`xattr` 읽기/쓰기** 이 두 가지 기능을 Rust 모듈로 먼저 만드시면 됩니다.


### 동기화 문제

네, 결론부터 말씀드리면 **"훅마크 방식(SQLite 동기화)보다 훨씬 안전하지만, '충돌(Conflict)' 문제는 여전히 발생할 수 있습니다."**

하지만 그 충돌의 성격이 완전히 다릅니다. 훅마크의 충돌이 **"데이터 파손(Corruption)"** 에 가깝다면, 선생님 방식의 충돌은 **"단순한 정리 대상(Mergeable)"**입니다.

비교를 통해 왜 더 안전한지, 그리고 남은 위험은 어떻게 처리해야 하는지 설명해 드릴게요.

#### 1. 훅마크가 동기화 지옥에 빠진 이유 (Binary DB)

훅마크는 SQLite라는 **바이너리 파일(0과 1로 된 덩어리)** 을 통째로 동기화합니다.

- **시나리오:** Mac A에서 링크 하나를 추가하고, 동시에 Mac B에서 다른 링크를 추가했습니다.
- **결과:** 드롭박스/iCloud는 이 두 바이너리 파일을 합칠 줄 모릅니다. 그래서 하나는 살리고 하나는 `Conflicted Copy`로 만들어버리거나, 재수 없으면 **파일 구조가 깨져서(Corrupt) DB가 아예 안 열립니다.**
- **복구:** 사용자가 직접 SQLite 뷰어를 열어서 데이터를 합칠 수 있을까요? 불가능합니다. 그래서 데이터가 유실됩니다.

#### 2. 선생님 앱(JSONL)이 더 안전한 이유 (Text Based)

선생님 앱은 **텍스트 파일(JSONL)**을 씁니다. 이게 '신의 한 수'입니다.
- **시나리오:** 똑같이 Mac A와 B에서 동시에 수정했습니다.
- **결과:** 드롭박스가 `data.jsonl`과 `data (Conflicted Copy).jsonl` 두 개의 텍스트 파일을 만듭니다.
- **차이점:**
    1. **깨지지 않음:** 텍스트 파일이라 데이터 자체는 멀쩡합니다.
    2. **합치기 쉬움:** 사람이 메모장으로 열어서 붙여넣기 할 수도 있고, **앱이 자동으로 합칠 수도 있습니다.**

#### 3. 발생할 수 있는 문제와 해결책: "자동 병합(Auto-Merge)"

"동기화 문제가 생기지 않을까?"라고 물으셨죠? 네, 생깁니다.
iCloud나 드롭박스를 쓰는 한, 두 컴퓨터에서 동시에 쓰면 무조건 파일이 두 개로 갈라집니다.
하지만 Rust로 만든 선생님의 앱은 이걸 **우아하게 해결**할 수 있습니다.

##### 💡 해결 전략: "충돌 파일 흡수하기"

앱이 켜질 때(혹은 파일 변경 감지 시) 다음 로직을 실행하도록 만드세요.
1. **탐색:** 데이터 폴더에 `conflicted copy` (드롭박스) 또는 `(2)` (iCloud) 같은 이름이 붙은 파일이 있는지 스캔합니다.
2. **흡수 (Merge):**
    - 메인 파일(`data.jsonl`)과 충돌 파일(`conflicted.jsonl`)을 모두 읽습니다.
    - **UUID 기준**으로 데이터를 합칩니다.
    - **규칙:** 같은 UUID가 양쪽에 있다면? `updated_at` 타임스탬프가 더 최신인 것을 채택합니다.
3. **정리:** 데이터가 안전하게 메모리에 합쳐졌다면, 충돌 파일을 `archive` 폴더로 치우거나 메인 파일에 덮어씁니다(Rewrite).

#### 4. 결론: 사용자에게 어필할 포인트

이 기술적 차이를 마케팅 포인트로 삼으세요.

> **"Hookmark는 동기화하다가 DB가 깨질 수 있습니다. HookLink는 절대 깨지지 않습니다. 혹시 충돌이 나도, 우리가 알아서 합쳐드립니다."**

**요약:**
1. **안전성:** 파일 기반(JSONL)이라 데이터 구조가 망가지는 일은 없습니다. (훨씬 안전함)
2. **동기화 문제:** 클라우드 특성상 '파일 복제'는 일어나지만, **'자동 병합' 로직**만 넣으면 사용자는 문제라고 느끼지 못할 것입니다.

### 기타 문제해결법

다음 주 백엔드 작업하실 때 **"파일 로더(File Loader)"** 부분에 이 **'충돌 파일 감지 및 병합'** 로직을 꼭 넣으시길 권장합니다. 이게 있으면 "동기화가 완벽하다"는 평을 들을 수 있습니다.
지금까지 우리는 **성능(Rust), 데이터 주권(JSONL), 동기화(Merge), 링크 유실(Self-Healing)** 이라는 굵직한 기술적 난제들을 해결했습니다. 이 정도면 훅마크의 핵심 약점 80%는 커버한 셈입니다.

하지만 훅마크 사용자들이 포럼에서 호소하는 **'나머지 20%'의 짜증 포인트**가 아직 남아있습니다. 특히 **macOS 환경 특유의 문제**와 **사용자 심리**와 관련된 부분입니다.

놓치면 안 될 **마지막 3가지 체크리스트**를 정리해 드립니다.

#### 1. "권한 지옥(Permission Hell)" 탈출하기

맥 사용자라면 누구나 겪는 고통입니다. 훅마크는 수많은 앱을 제어하기 위해 **'손쉬운 사용(Accessibility)'** 과 **'자동화(Automation)'** 권한을 과도하게 요구합니다.

- **훅마크의 문제:** macOS 업데이트가 되거나 앱이 업데이트되면 권한이 풀리는 경우가 잦습니다. 이때 훅마크는 "권한이 없습니다"라는 딱딱한 에러만 뱉거나, 아예 먹통이 됩니다. 사용자는 왜 안 되는지 모른 채 앱을 지워버립니다.
- **HookLink의 대처법: "능동적 건강 검진 (Proactive Health Check)"**
    - **Onboarding:** 앱을 처음 켤 때, 권한 설정 창으로 바로 보내주는 친절한 가이드(UI)가 필수입니다.
    - **Permission Watcher:** 백그라운드에서 주기적으로 권한 상태를 체크하세요. 만약 옵시디언 연동 권한이 풀렸다면, 사용자가 링크를 클릭해서 실패하기 _전에_ 런처에 **"⚠️ 옵시디언 연결 복구가 필요합니다"** 라고 미리 알려줘야 합니다.
    - **팁:** Rust에서 `AXIsProcessTrusted()` 같은 API로 권한 상태를 0.1초 만에 확인할 수 있습니다.

#### 2. "빈 화면의 공포(The Cold Start Problem)" 해결

훅마크를 처음 설치하면 **아무것도 없는 빈 창**이 뜹니다. "그래서 이걸로 뭘 하라는 거지?"라는 생각이 들게 만들죠.

- **훅마크의 문제:** 사용자가 직접 문서를 열고 단축키를 눌러봐야만 작동 방식을 알 수 있습니다. 학습 곡선이 높습니다.
- **HookLink의 대처법: "자체 튜토리얼 데이터 (Playground)"**
    - 앱을 설치하자마자 `data.jsonl`이 비어있지 않게 하세요.
    - **기본 데이터:** "👋 HookLink 사용법.pdf", "🔗 이 링크를 눌러보세요(웹사이트)" 같은 예제 데이터를 미리 3~4개 넣어두세요.
    - 사용자가 런처를 띄우자마자 검색어 없이도 이 예제들이 보이고, 누르면 바로 작동하게 하여 **"아, 이렇게 쓰는 거구나"** 를 10초 안에 깨닫게 해야 합니다.

#### 3. "쓰레기 링크(Link Clutter)" 자동 청소

사용하다 보면 수천 개의 링크가 쌓입니다. 훅마크는 이걸 정리할 방법이 마땅치 않습니다. 검색 결과에 1년 전의 쓸모없는 링크가 계속 뜹니다.

- **훅마크의 문제:** 모든 링크가 영원히 남습니다. 나중엔 검색 결과가 너무 지저분해져서 신뢰도가 떨어집니다.
- **HookLink의 대처법: "스마트 에이징 (Smart Aging)"**
    - **Decay Algorithm:** 검색 랭킹을 짤 때, `최근 사용일(Last Accessed)`에 가중치를 두세요. 오래된 링크는 검색 순위 아래로 가라앉게 만드세요.
    - **Auto-Archive (제안):** "6개월 동안 한 번도 안 열어본 링크는 검색에서 제외(아카이브)하시겠습니까?" 같은 기능을 설정에 넣어두면, 런처가 항상 빠릿빠릿한 느낌을 줄 수 있습니다.

### 🚀 최종 점검: "앱 스토어 배포" 생각 중이신가요?

이건 비즈니스적으로 매우 중요한 질문입니다.

- **Sandbox 문제:** 선생님 앱(HookLink)은 다른 앱의 파일 경로를 추적하고, `xattr`를 쓰고, 창을 제어해야 합니다. 이 기능들은 Apple의 **App Store 샌드박스 정책(App Sandbox)**과 정면으로 충돌합니다.
- **제언:** 훅마크도 앱 스토어에 없습니다(DMG 직접 배포). 선생님 앱도 초기에는 **웹사이트를 통한 직접 판매(Paddle 등 결제 모듈 붙여서 DMG 배포)** 가 현실적일 것입니다.
- 앱 스토어에 올리려면 기능을 대거 삭제해야 할 수도 있으니, **"홈페이지 판매 -> 라이선스 키 입력"** 방식으로 개발 방향을 잡으시는 게 좋습니다.

정리하자면:
지금 기술적(Rust, JSONL)으로는 훌륭합니다. 여기에 ①친절한 권한 안내 UI, ②초기 예제 데이터, ③오래된 링크 뒤로 보내기 이 세 가지 디테일만 더하면, 사용자는 훅마크보다 훨씬 **"세련되고 관리받는 느낌"** 을 받을 것입니다.

이것으로 기획 단계의 상담은 거의 완성된 것 같습니다.

혹시 **"가격 책정($9.99 vs 구독)"** 이나 "마케팅 멘트" 쪽으로 더 다듬고 싶은 부분이 남으셨나요? 아니면 바로 개발로 뛰어드실 준비가 되셨나요?

---

# 섹션 5: Comparison

**목표:** 단순한 '가성비' 호소가 아니라, **'기술적 세대교체(Generation Shift)'** 임을 강조합니다.

### 1. 헤드라인 & 서브

- 헤드라인: "1세대 그래프 도구의 시대는 끝났습니다." (The Era of Legacy Graph Tools is Over.)
- 서브 헤드라인:
    무거운 스크립트, 깨지는 데이터베이스, 수동 연결의 노가다.
    HookLink는 이 모든 문제를 아키텍처 레벨에서 해결했습니다.

### 2. The Truth Table (강화된 비교표)

단순히 기능 유무(O/X)가 아니라, **'어떤 기술을 썼는지'** 를 명시하여 신뢰도를 높입니다.

| **비교 항목**  | **기존 연결 도구 (Competitor H)**  | **HookLink (차세대 엔진)**        | **비고 (Why?)**   |
| ---------- | ---------------------------- | ---------------------------- | --------------- |
| **핵심 엔진**  | **AppleScript** (느림, 불안정)    | **Rust Native** (즉시 반응)      | _메모리 점유율 1/10_  |
| **연결 방식**  | **1:1 수동 연결** (Manual Graph) | **맥락 기반 자동 연결** (Set Theory) | _노가다 vs 자동화_    |
| **데이터 형태** | **SQLite DB** (암호화/불투명)      | **JSONL 텍스트** (투명/개방형)       | _데이터 주권 보장_     |
| **복잡도**    | **O(N²)** (파일이 늘면 느려짐)       | **O(1)** (늘어도 속도 일정)         | _수만 개 링크도 0.1초_ |
| **링크 유지력** | **Alias 의존** (종종 깨짐)         | **Inode + UUID 이중 추적**       | _파일 추적률 99.9%_  |
| **가격 정책**  | **매년 $70** (임대 모델) 💸        | **$4.99** (얼리버드 평생 소장) ☕️    | _구독료 0원_        |

### 3. The "Why" (비교 근거 상세 - 3단 팩트 체크)

표 아래에 **"왜 이 차이가 중요한가?"** 를 설명하는 3가지 카드를 배치하여 쐐기를 박습니다.
#### Fact 1. 본드(Glue) vs 엔진(Engine)

> "스크립트 덩어리가 아닙니다."
> 기존 도구는 수백 개의 AppleScript로 앱들을 억지로 붙여놓은 형태입니다. 그래서 크롬이 업데이트되면 앱이 멈추고, 로딩이 걸립니다.
> HookLink는 Rust로 작성된 네이티브 엔진입니다. 스크립트를 거치지 않고 OS와 직접 통신하므로, 딜레이가 구조적으로 발생할 수 없습니다.

#### Fact 2. 선 긋기(Wiring) vs 담기(Grouping)

> "일일이 연결하느라 시간 낭비하지 마세요."
> 파일 A와 B를 연결하고, B와 C를 연결하는 1:1 방식(Graph)은 파일이 늘어날수록 관리가 불가능해집니다.
> HookLink는 '태그 집합(Set)'을 사용합니다. #Project_A 태그 하나만 달면, 그 안의 100개 파일이 즉시 상호 연결됩니다. 복잡한 선 긋기 노동에서 해방되세요.

#### Fact 3. 블랙박스(Blackbox) vs 텍스트(Text)

> "당신의 데이터는 당신이 읽을 수 있어야 합니다."
> 알 수 없는 바이너리 DB에 데이터를 가두지 마세요. DB가 깨지면 복구할 수 없습니다.
> HookLink는 모든 데이터를 '텍스트 파일(JSONL)'로 저장합니다. 메모장으로 열 수 있고, 깃(Git)으로 백업할 수 있으며, 앱이 없어져도 데이터는 온전히 당신의 것입니다.

### 4. 하단 CTA (Call To Action)

비교를 보고 설득된 사용자를 바로 결제로 유도합니다.
- **문구:** **"더 빠르고, 더 안전하고, 더 합리적입니다. 망설일 이유가 있나요?"**
- 버튼:
    [ HookLink로 갈아타기 (얼리버드 $4.99) ]
    기존 훅마크 사용자 환영 | 데이터 마이그레이션 지원(예정)

## 기술비교 블로그 - 점 잇기 놀이는 그만두세요 - 왜 1:1 연결 방식은 구시대적인가

**(Stop Connecting Dots: Why 1:1 Linking is Obsolete)**

---

### 서론: 위대한 비전, 아쉬운 구현

우리는 모두 "모든 것을 연결하겠다"는 비전에 빚을 지고 있습니다. 테드 넬슨(Ted Nelson)의 제너두(Xanadu) 프로젝트부터 최근의 연결 도구들까지, 그들은 파일과 웹, 노트를 연결한다는 발상이 얼마나 강력한지 증명해 냈습니다.

하지만 2026년의 우리는 묻습니다. **"왜 파일을 연결하는 일이 이렇게 힘들어야 합니까?"**

우리가 존경했던 1세대 도구들은 태생적인 한계를 안고 있습니다. 느린 스크립트 언어, 불투명한 데이터베이스, 무엇보다 사용자가 일일이 '선'을 그어야 하는 **수동적인 연결 방식**입니다.

우리는 이 문제를 바닥부터 다시 생각했습니다. 그리고 답을 찾았습니다.

HookLink는 그렇게 탄생했습니다.

---

### 1. Philosophy: 악수(Handshake) 대신 방(Room)으로

1세대 도구들의 가장 큰 문제는 **'파일 A'와 '파일 B'를 직접 묶는 방식(Pairwise Linking)** 을 사용한다는 점입니다.
이것은 마치 파티에 온 10명의 친구를 서로 소개해주기 위해 45번이나 일일이 악수를 시키는 것과 같습니다.

- 파일이 3개면 연결은 3번.
- 파일이 100개면 연결은 수천 번.
- 하나만 끊어져도 복구가 불가능한 '디지털 뜨개질'입니다.

HookLink는 '집합(Set)'을 사용합니다.
굳이 파일끼리 악수를 시키지 마세요. 그냥 **#2026_프로젝트**라는 **'방(Context)'** 에 그들을 초대하세요.

- 같은 방에 있는 것만으로도 그들은 이미 연결되어 있습니다.
- A 파일을 열면, 같은 방에 있는 B, C, D가 즉시 호출됩니다.
- **1세대 방식:** $N^2$의 복잡도 (파일이 늘어나면 관리가 불가능)
- **HookLink:** $O(1)$의 단순함 (태그 하나면 끝)

---

### 2. Architecture: 스크립트(Scripts)가 아닌 엔진(Engine)으로

기존의 연결 도구들은 수백 개의 `AppleScript`를 사용하여 앱들을 억지로 붙여놓은 형태(Glue Code)입니다. 본드로 집을 지은 격입니다.

- **The Problem:** 파인더가 버벅거리거나 크롬이 업데이트되면, 스크립트도 함께 깨집니다. 링크 하나를 만들기 위해 무거운 팝업창을 띄우고 로딩을 기다려야 합니다.
- **Our Solution (Rust):** 우리는 타협하지 않았습니다. HookLink는 시스템 프로그래밍 언어인 **Rust**로 작성되었습니다. 스크립트를 거치지 않고 macOS의 Accessibility API와 직접 통신합니다.
    - **Result:** 메모리 점유율은 1/10, 반응 속도는 0.1초 미만입니다. 당신의 맥북 팬(Fan)은 더 이상 돌지 않습니다.

---

### 3. Data: 블랙박스(DB)에서 텍스트(Text)로

소프트웨어가 업데이트되다가 데이터베이스가 깨져서(Corruption) 수년간 모은 링크를 날린 경험이 있으신가요? 혹은 앱 사용을 중단했더니 내 데이터가 인질처럼 잠겨버린 적은요?

우리는 **"사용자가 읽을 수 없는 데이터는 데이터가 아니다"** 라고 믿습니다.
- **Plain Text Storage:** HookLink의 모든 데이터는 당신의 로컬 폴더에 `JSONL` 형식의 텍스트 파일로 저장됩니다.
- **Transparency:** 메모장으로 열어볼 수 있고, 깃(Git)으로 백업할 수 있으며, 충돌이 발생해도 사람이 직접 수정할 수 있습니다.
- **Self-Healing:** 파일 이름을 바꾸거나 폴더를 옮겨도 괜찮습니다. 우리는 macOS의 파일 시스템 깊은 곳(Inode & xattr)을 추적하여 끊어진 연결을 스스로 복구합니다.

---

### 4. Pricing: 임대(Rent)에서 소유(Own)로

도구는 구독하는 것이 아니라, 내 손에 쥐어지는 것이어야 합니다. 망치를 매달 돈을 내고 빌려 쓰지 않는 것처럼 말이죠.

1세대 도구들은 매년 $70에 달하는 구독료를 요구합니다. 결제를 멈추면 업데이트도 멈춥니다. 우리는 이 모델이 지식 노동자에게 불필요한 피로감을 준다고 생각합니다.

HookLink는 **단 한 번의 구매(One-time Purchase)** 를 지향합니다. 커피 한 잔 값으로, 이 도구는 영원히 당신의 것이 됩니다.

---

### 결론: 연결의 새로운 표준

우리는 이전 세대의 도구들보다 기능이 적을 수도 있습니다. 화려한 시각화 도구도 없고, 수백 개의 앱을 모두 지원하지도 않을 수 있습니다.

하지만 우리는 확신합니다.

더 가볍고(Lightweight), 더 투명하고(Transparent), 더 합리적인(Affordable) 도구가 결국 승리할 것이라고요.

**복잡한 선 긋기를 멈추고, 이제 '맥락'을 정의하세요.**

[ **HookLink 베타 참여하기** ]


---

# 섹션 6: Pricing (가격 정책)

**목표:** "지금 안 사면 손해"라는 느낌 주기 (박리다매).
- **헤드라인:** **"구독료 0원. 커피 한 잔 값으로 평생 소장하세요."**

#### 카드 1. Free (체험판)
- **Title:** Starter
- **Price:** $0
- **Features:**
    - 모든 기능 사용 가능
    - 최대 50개 링크 생성
    - **50개 이하 읽기/검색/실행 평생 무제한** (중요!)

#### 카드 2. Early Bird (프로)
- **Title:** Pro Lifetime
- **Price:** ~~($9.99)~~ -> **$4.99** (Limited Offer)
- **Features:**
    - **무제한** 링크 생성
    - 우선 기술 지원
    - 평생 무료 업데이트
    - _100 Copy Left_ (긴급성 부여)

## HookLink 가격 및 라이선스 전략 기획서 (Ver 1.0)

핵심 전략: "Anti-Subscription (구독 거부)" & "Own Your Tools (도구 소유)"

### 1. 시장 현황 및 문제 정의 (Why Now?)

#### 1.1. 경쟁사(Hookmark)의 가격 구조 분석

- **현황:** Hookmark는 **'구독형 업데이트(Updates License)'** 모델을 취하고 있습니다.
    - **Pro:** $69.99 (약 95,000원) / 년 1
    - **Standard:** $29.99 (약 40,000원) / 년 2
        
- **Pain Point:**
    - **높은 진입 장벽:** 단순 유틸리티 앱에 매년 70달러를 지불하는 것은 사용자에게 큰 심리적 저항감을 줍니다. 3
    - **업데이트 인질극:** 1년 뒤 구독을 갱신하지 않으면 최신 macOS 대응 업데이트를 받을 수 없습니다. 사용자는 이를 "강제 구독"으로 인식하여 불쾌감을 느낍니다. 4444

#### 1.2. 2026년 앱 시장의 트렌드: '구독 피로'

- **Subscription Fatigue:** 사용자는 캘린더, 메모 앱까지 구독을 요구하는 상황에 지쳐 있습니다. 5555
- **소유욕의 부활:** 2025년 시장 트렌드는 **"한 번 사면 내 것(Pay Once, Own Forever)"**인 앱으로 회귀하고 있습니다. Rectangle Pro($9.99)나 Shottr($12) 같은 단일 기능 앱들의 성공이 이를 증명합니다. 6666

---

### 2. HookLink 가격 정책 (Pricing Model)

우리는 경쟁사의 약점을 정확히 타격하여, **"가장 합리적인 대안"** 으로 포지셔닝합니다.

#### 2.1. 모델: 영구 라이선스 (Lifetime License)

- **정의:** 한 번 결제하면 평생 사용 가능. (v1.x 버전 내 기능 업데이트 무료 포함)
- **가격 책정 (Pricing Tier):**
    - **Super Early Bird (베타):** **$4.99** (선착순 100명) - _Hookmark 대비 93% 저렴_
    - **Launch Price (정식 출시):** **$9.99**
    - **Normal Price (목표 정가):** **$14.99**
- **전략적 의도:**
    - **커피 한 잔 값 ($4.99):** 고민 없이 결제할 수 있는 **'충동구매 가격대(Impulse Buy Range)'** 입니다. 초기 바이럴을 위한 미끼 상품입니다. 7
    - **가격 앵커링 (Anchoring):** 홈페이지 비교표에서 Hookmark의 **$70/년**을 먼저 보여준 뒤, 우리 앱의 **$4.99**를 보여주면 사용자는 이를 '공짜'처럼 느낍니다.

#### 2.2. 무료 정책 (Freemium Strategy): "The 50-Link Trap"

- **구조:** 기능 제한(Feature Lock)이 아닌, **용량 제한(Usage Limit)** 방식.
- **Free Tier:**
    - 모든 기능(딥링크, 태깅, 검색 등) 100% 사용 가능.
    - 단, **신규 링크 생성 50개**로 제한.
    - **★ 핵심:** 50개가 넘어도, **기존 링크의 검색, 실행, 읽기는 평생 무료.**
- **논리적 근거:**
    - **습관 형성:** 50개의 링크를 만들 때쯤이면 사용자는 이미 HookLink에 중독(Lock-in)되어 있습니다. 이때 결제창을 띄우면 전환율이 가장 높습니다.
    - **데이터 인질 우려 제거:** "나중에 돈 안 내면 내 자료 못 보나?"라는 두려움을 **'읽기 평생 무료'** 정책으로 원천 차단합니다. 이는 훅마크나 노션이 줄 수 없는 강력한 안정감입니다. 8

---

### 3. 수익성 및 지속 가능성 방어 논리 (Sustainability)

사용자나 투자자가 **"한 번 팔아서 서버비는 어떻게 감당하냐?"** 고 물을 때의 답변입니다.

#### 3.1. 제로 마진 코스트 (Zero Marginal Cost)

- **Local-First:** HookLink는 클라우드 서버를 쓰지 않습니다. 모든 데이터는 사용자 로컬(JSONL)에 저장됩니다. 9
- **No AI Tax:** OpenAI API 등을 쓰지 않으므로, 사용자가 늘어난다고 변동 비용(Variable Cost)이 발생하지 않습니다. 10
- **결론:** 판매액($4.99)에서 결제 수수료를 뺀 나머지가 **100% 순이익**입니다. 유지보수 비용이 거의 0에 수렴하므로 구독 모델이 필요 없습니다.

#### 3.2. 유료 업그레이드 (Paid Upgrade) 모델 (Plan B)

- 만약 v2.0(대규모 기능 추가)을 출시할 경우, **Panic(Nova)의 모델**을 따릅니다.
- 기존 구매자는 v1.0을 평생 쓸 수 있지만, v2.0의 신기능을 원하면 **할인가($5)** 에 업그레이드합니다. 이는 사용자에게 '선택권'을 주므로 반발이 없습니다.

---

### 4. 결제 및 배포 인프라 (Implementation)

**[macOS 앱 라이선스 정책 조사]** 보고서에 따라 **직접 판매(Direct Sales) + MoR** 방식을 채택합니다.

- **플랫폼:** **Lemon Squeezy** (또는 Paddle)
    - **이유:** 글로벌 세금(VAT) 이슈를 100% 대행해 줌. 인디 개발자가 세무 리스크를 피할 수 있는 유일한 방법.
    - **수수료:** 약 5% + $0.50. (초기 $4.99 판매 시 수수료 비중이 높지만, 법적 안전 비용으로 간주)
- **배포:** 홈페이지에서 DMG 파일 직접 다운로드.
    - **이유:** **샌드박싱(Sandboxing) 회피.** HookLink의 핵심 기능(파일 추적, 딥링크, 창 제어)은 App Store 샌드박스 환경에서는 구현 불가능합니다.

---

### 5. 홈페이지 적용 가이드 (Copywriting)

홈페이지의 **Pricing 섹션**에 들어갈 실제 문구입니다.

#### **헤드라인**

> "구독료 0원. 도구는 빌리는 게 아니라 소장하는 것입니다."
> (No Subscriptions. Buy Once, Own Forever.)

#### **가격표 (Pricing Table)**

| **Starter (Free)**  | **Pro (Early Bird)**       |
| ------------------- | -------------------------- |
| **$0**              | ~~**$14.99**~~ → **$4.99** |
| [ 다운로드 ]            | [ 구매하기 ]                   |
| ✅ **모든 기능 체험**      | ✅ **모든 기능 무제한**            |
| 🚧 **링크 생성 50개 제한** | 🚀 **링크 생성 무제한**           |
| 👀 **읽기/검색 평생 무료**  | 🔄 **평생 무료 업데이트**          |
| 💾 **데이터 로컬 저장**    | 🤝 **우선 기술 지원**            |

#### 하단 안심 문구 (Trust Badges)

- 🛡️ **7일 묻지마 환불 보장** (마음에 안 들면 메일 한 통 주세요.)
- 🔓 **No Vendor Lock-in** (앱을 지워도 데이터는 텍스트 파일로 남습니다.)
- 💳 **Secure Payment by Lemon Squeezy**


---

# ✍️ FAQ

우리는 다음 5가지 불안요소를 제거해야 합니다.

1. **중복 투자 의심:** "나 이미 레이캐스트 쓰는데 굳이?"
2. **먹튀 의심 (Sustainability):** "평생 무료라니, 개발자 도망가는 거 아냐?"
3. **데이터 인질 의심 (Lock-in):** "앱 안 쓰게 되면 내 링크 다 날아가나?"
4. **성능 의심:** "파일 옮기면 링크 다 깨지는 거 아냐? (기존 훅마크 트라우마)"
5. **환불/리스크:** "샀는데 별로면 어떡해?"

#### 1. 중복 투자 방어 (Vs. Raycast/Alfred)

- **Q. 저는 이미 Raycast(또는 Alfred)를 잘 쓰고 있습니다. 이게 왜 필요한가요?**
- A. 레이캐스트는 '도구'를 열지만, HookLink는 '작업'을 엽니다.
    레이캐스트는 PDF 뷰어를 실행해 줄 뿐입니다. 하지만 HookLink는 그 PDF의 14페이지, 세 번째 문단을 바로 열어줍니다.
    레이캐스트는 슬랙을 켜주지만, HookLink는 **'기획팀 채널의 특정 스레드'** 로 바로 이동합니다.
    Raycast와 함께 쓰세요. 앱 실행은 Raycast로, 맥락 연결은 HookLink로. 둘은 최고의 콤비입니다.

#### 2. 지속 가능성 방어 (Sustainability)

- **Q. 구독료도 없이 '평생 소장'이라니, 나중에 업데이트 중단되는 거 아닌가요?**
- A. 우리는 서버 비용이 '0원'인 구조를 만들었습니다.
    대부분의 앱이 구독을 받는 이유는 클라우드 서버 유지비 때문입니다. 하지만 HookLink는 모든 데이터를 **당신의 컴퓨터(Local)** 에서 처리합니다.
    우리에겐 매달 나가는 고정비가 없습니다. 따라서 한 번의 판매로도 충분히 지속 가능한 비즈니스 모델입니다. 안심하고 평생 쓰세요.

#### 3. 데이터 주권 방어 (No Lock-in)

- **Q. 만약 제가 HookLink를 더 이상 안 쓰게 되면, 저장해둔 링크는 다 사라지나요?**
- A. 절대 사라지지 않습니다. 데이터는 100% 당신의 것입니다.
    HookLink는 알 수 없는 암호화 DB를 쓰지 않습니다. 모든 링크 정보는 Documents/HookLink/data.jsonl이라는 투명한 텍스트 파일에 저장됩니다.
    앱을 삭제해도 파일은 남습니다. 메모장으로 열어서 내용을 확인하거나, 다른 앱으로 데이터를 옮기는 것도 자유롭습니다.

#### 4. 기술적 트라우마 방어 (Broken Links)

- **Q. 파일을 다른 폴더로 옮기거나 이름을 바꾸면 링크가 깨지나요?**
- A. HookLink는 끝까지 쫓아가서 연결합니다.
    단순히 파일 경로(주소)만 기억하는 게 아닙니다. macOS 파일 시스템의 고유 ID(Inode)와 자체 추적 기술(xattr)을 이용해 파일이 어디로 이사 가든 찾아냅니다.
    마음껏 파일을 정리하세요. 연결은 우리가 책임집니다.

#### 5. 리스크 제거 (Refund Policy)

- **Q. 제 워크플로우랑 안 맞으면 어떡하죠?**
- A. 7일간 충분히 써보시고 결정하세요.
    구매 후 7일 이내라면, 이유를 묻지 않고 100% 환불해 드립니다.
    우리는 당신이 억지로 이 앱을 쓰길 원하지 않습니다. 정말 도움이 될 때만 HookLink를 소장하세요.

### 💡 팁: FAQ 배치 순서

가장 많이 하는 질문(Raycast 비교)을 1번에 두어 시선을 잡고, 마지막(환불)에 안심을 주어 결제 버튼을 누르게 하는 **'의심 해소의 깔때기'** 순서로 배치하는 것이 좋습니다.

이렇게 작성하면 FAQ 섹션이 단순한 정보 전달을 넘어 **강력한 세일즈 도구**가 될 것입니다. 이 내용으로 확정하시겠습니까?

---

# Footer (마무리)

- **Contact:** 버그 제보 / 기능 요청 (이메일/디스코드)
- **Legal:** 이용약관 / 개인정보처리방침
- **Social:** Twitter(X) / GitHub (개발자 친화적 이미지)

